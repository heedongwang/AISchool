
public class Ex00출력문 {

   public static void main(String[] args) {

      // ctrl + + : 글씨 확대
      // ctrl + - : 글씨 축소
      
      // 주석 : 컴파일에 영향을 주지 않는 코드
      
      // main 안 쪽에 앞으로 실행 코드를 작성해주자
      // - main 안 쪽 코드만 컴파일을 통해서 실행되기 때문
      
      // 1. 출력문
      // : 결과값을 콘솔창을 통해 확인해보고 싶을 때
      
      System.out.println(12345678);
      // ctrl + s : 저장
      // ctrl + f11 : 실행
      
      // 문자열을 출력하고 싶으면 ""(큰따옴표)로 감싸주자
      
      // syso + ctrl + spacebar
      System.out.println("조자연");
      
      System.out.print(12345678);
      System.out.print("조자연");
      
      // ln : line new - 출력후 개행(엔터)
      // ln이 없는 - 출력만 한다(개행 x)
      
      
      
   }

}



public class Ex01변수 {

   public static void main(String[] args) {

      // 변수
      // : 프로그래밍에서 데이터를 담을 수 있는 공간
      
      // a라는 공간에 정수형(숫자)데이터 3을 저장
      // 자료형 변수명 = 변수에 저장하고 싶은 데이터 ;
      int a = 3; // 선언 및 초기화
      System.out.println(a);
      
      // b라는 공간에 정수형 데이터 5를 저장
      // 1) 선언 : 데이터가 들어갈 공간만 만들어 놓기
      int b;
      // 2) 초기화(할당): 변수에 처음으로 값을 대입하는 것
      b = 5;
      // b에 7을 넣고싶으면?
      b = 7;
      // 변수의 선언은 클래스에서 딱 한번만 할 수있다!
      // int b = 7;
      // 3) 재할당
      // - 변수는 한 번 값을 대입하고 나면 뒤쪽에서 또 다른 값을 
      //   넣어 줄 수있어요
      System.out.println(b);
      
   }

}


public class Ex02상수 {

   public static void main(String[] args) {

      // 상수
      // : 변하지 않는 수, 불변하는 
      // : 프로그래밍 언어에서는 데이터를 담을 수 있는 공간
      // 단, 한번 담아놓으면 아래쪽 코들에서 값을 변경할 수가 없다
      
      // 키워드 : final
      // final 자료형 변수명 = 데이터 값;
      final int a = 3;
      // 선언 및 초기화
      
      // a = 5; --> 오류가 나는 코드
      // 상수는 초기화 이후로 재할당이 불가능하다
      
      
      
   }

}




public class Ex03자료형 {

   public static void main(String[] args) {

      // 1. 논리형
      // 1) boolean : 1byte(8bit - 2^8)
      // true/false 값만 저장할 수 있는 자료형 (참/거짓)
      // 제외한 다른 값을 넣으면 type mismatch error
      
      boolean isHot = true;
      System.out.println(isHot);
      
      // 2. 문자형
      // 1) char : 2byte
      // 문자 한 개를 저장 할 수 있는 자료형
      // ''(작은따옴표)로 감싸줘야 한다
      // + 유니코드 문자도 저장 할 수 있다
      char firstName = '조';
      
      // 3. 정수형
      // 1) byte : 1byte
      byte num1 = 127;
      // 1byte - 8bit - 2^8 - 256개
      // -128 ~ 127
      
      // 2) short : 2byte(16bit)
      short num2 = 128;
      
      // 3) int : 4byte - 정수형 데이터 타입 중에서 기본으로 사용되는 자료형
      // -21억 ~ 21억
      int num3 = 200;
      // 이유 : 기본데이터 타입을 선언을 하면 메모리 공간을 차지함
      // ex) 내가 long을 선언을 하는 순간 메모리 8byte의 공간을 차지
      // byte, short는 너무 작고, long은 너무 커요.. 중간 int
      // - 메모리 공간을 좀더 효율적 사용하기 위함
      // 4) long : 8byte
      
      
      
      
      
   }

}






public class Ex03자료형 {

   public static void main(String[] args) {

      // 1. 논리형
      // 1) boolean : 1byte(8bit - 2^8)
      // true/false 값만 저장할 수 있는 자료형 (참/거짓)
      // 제외한 다른 값을 넣으면 type mismatch error
      
      boolean isHot = true;
      System.out.println(isHot);
      
      // 2. 문자형
      // 1) char : 2byte
      // 문자 한 개를 저장 할 수 있는 자료형
      // ''(작은따옴표)로 감싸줘야 한다
      // + 유니코드 문자도 저장 할 수 있다
      char firstName = '조';
      
      // 3. 정수형
      // 1) byte : 1byte
      byte num1 = 127;
      // 1byte - 8bit - 2^8 - 256개
      // -128 ~ 127
      
      // 2) short : 2byte(16bit)
      short num2 = 128;
      
      // 3) int : 4byte - 정수형 데이터 타입 중에서 기본으로 사용되는 자료형
      // -21억 ~ 21억
      int num3 = 200;
      // 이유 : 기본데이터 타입을 선언을 하면 메모리 공간을 차지함
      // ex) 내가 long을 선언을 하는 순간 메모리 8byte의 공간을 차지
      // byte, short는 너무 작고, long은 너무 커요.. 중간 int
      // - 메모리 공간을 좀더 효율적 사용하기 위함
      // 4) long : 8byte
      
      // 4. 실수형 :  소수점이 붙은 숫자들
      // 1) float : 4byte
      float pi2 = (float) 3.141592;
      // 2) double : 8byte
      double pi1 = 3.141592;
      
      // * 형변환 (Cast/Casting) - convert....
      // 1) 강제형변환(명시적형변환)
      // - 큰 자료형을 작은 자료형의 변수에 담을 때 진행
      // 2) 자동형변환(묵시적형변환)
      // - 작은 자료형을 큰 자료형의 변수에 담을 때 진행
      double pi3 = pi2; // pi2 -> float
      
 
      
   }

}


int num = 107;
      // char자료형으로 형변환 해서 출력했을 때 a라는 문자 한개가
      // console보이는지 확인해보자 (ch라는 변수명)
      char ch = (char)num;
      System.out.println(ch); // a


System.out.println(7 + 3 + "7");
      System.out.println(7 + "3" + 7);
      System.out.println("7" + 3 + 7);




package 이항연산자;

import java.util.Scanner;

public class Ex02산술연산자 {

   public static void main(String[] args) {

      // 1) 입력하는 도구 가져오기
      Scanner sc = new Scanner(System.in);
      // ctrl + shift + o : import 자동 진행
      
      // 2) 사용자로 부터 숫자 한개를 입력받아(세자리 숫자)
      // 3) num에 저장
      System.out.print("숫자를 입력하세요 >> ");
      int num = sc.nextInt();
      
      
      // 4) 백의자리 숫자 구하기
      System.out.println("백의 자리 숫자 : "+ num/100);
      // 5) 십의자리 숫자 구하기 556 ---> 56 ---> 5
      // 789 ---> 89 ---> 8
      System.out.println("십의 자리 숫자 : "+ num%100/10);
      // 6) 일의 자리 숫자 구하기
      System.out.println("일의 자리 숫자 : "+ num % 10);
      // 786 % 10 ---> 6
      // 456 % 10 ---> 6
      
   }

}

package 단항연산자;

public class Ex01증감연산자 {

   public static void main(String[] args) {

      // ++, -- (앞/뒤)
      // num ++ ---> num = num + 1 (num += 1)
      int num = 3;
      
      System.out.println(num++); // 3
      // 증감연산자는 뒤에 붙어 있으면
      // 먼저 실행코드(출력문)가 동작하고 나서 연산을 진행한다
      // 콘솔에서는 볼 수 없지만 num = 4 인상태이다.
      System.out.println(--num); // 3
      // 증감 연산자는 앞에 붙어 있으면
      // 먼저 연산이 진행되고나서 실행코드가 동작한다
      
      
   }

}

package 이항연산자;

public class Ex03비교연산자 {

   public static void main(String[] args) {

      // < <= > >= ==(같다) !=(다르다)
      // 비교연산자들은 결과값으로 boolean 자료형을 돌려준다
      // - true/false
      
      int num1 = 3;
      int num2 = 7;
      
      System.out.println(num1 == num2);
      System.out.println(num1 != num2);
      
      
   }

}


package 삼항연산자;

import java.util.Scanner;

public class Ex02삼항연산자 {

   public static void main(String[] args) {

      // 1) 입력하는 도구가 필요하다
      Scanner sc = new Scanner(System.in);
      // 2) 출력문
      System.out.print("첫 번째 정수 입력 : ");
      // 3) 입력문 - num1에다가 저장
      int num1 = sc.nextInt();
      // 4) 출력문
      System.out.print("두 번째 정수 입력 : ");
      // 5) 입력문 - num2에다가 저장
      int num2 = sc.nextInt();
      // 6) 두 수의 차가 결과값으로 나와야한다
      // 큰숫자 - 작은숫자 
      // 어떤 수가 더 큰 숫자인지 비교!
      // num1 - num2 num1이 더크면
      // num2 - num1 num2가 더크면
      int result = num1>num2?num1-num2:num2-num1;
      
      System.out.println("두 수의 차 : "+result);
   }

}




프로그래밍 언어
: 컴퓨터와 소통하기 위한 언어
컴파일러(번역기)
: 프로그래밍 언어를 컴퓨터가 알아먹을 수있는 기계어로 번역해주는 기능을 하고 있다~

변수
: 데이터를 담을 수 있는 공간(변할 수 있는 수)
자료형  변수명  =  데이터;
int       num     =  5; --> 선언 및 초기화 구문

선언 : int num;
데이터가 들어갈 수 있는 공간만 만들어 놓는 것
초기화 : num = 5;
변수에 처음으로 값을 할당한다.
재할당 : num = 6;
변수에 값을 다시 대입해주는 것

상수 : 불변하는, 변하지 않는
프로그래밍 언어에서는 데이터를 담을 수 있는 공간
단, 초기화 후 재할당은 불가능하다 

final 자료형 변수명 = 데이터값;

기본데이터 타입 8가지
1. 논리형
   1) boolean : true/false (1byte)
2. 문자형
   1) char : (2byte) 문자 한 개, 유니코드 
   저장 할 때 ''(작은따옴표)를 사용해서 저장
3. 정수형
   1) byte (1byte) -128 ~ 127
   2) short (2byte)
   3) int (4byte)
   4) long (8byte)
4. 실수형
   1) float (4byte)
   2) double (8byte)

   float pi = 3.141592 ---> double

** 형변환 (Casting/Cast)
1) 강제형변환(명시적형변환)
큰 자료형을 작은 자료형으로 변환 할 때 사용한다

2) 자동형변환(묵시적형변환)
작은 자료형을 큰 자료형으로 변환 할 때 사용한다




연산자
피연산자(항)

식 : 피연산자와 연산자가 합쳐져 있는 것 
(조건식) 

기준 : 항의 개수를 기준으로 
- 단항 연산자
   1) 증감연산자 (++ , --)
      앞/뒤 - num++, ++num
      앞 : 연산이 먼저 이루어 진다음 코드가 실행된다
      뒤 : 실행코드가 동작한 다음 연산이 이루어진다
- 이항 연산자
   1) 산술 연산자 : + - * / %
      + : 문자열 연산도 가능하다!
      7 + "7" = "77"
      앞에있는 숫자가 자동으로 문자열 형변환이 된다
   2) 비교 연산자 : > >= < <= == !=
      결과값으로 boolean결과값을 돌려준다
   3) 논리 연산자 : !(NOT), &&(AND), ||(OR)
      피연산자(항)이 boolean type만 올 수 있다
      : true/false, 비교연산식
      - 부정연산자(NOT)
      !true -----> false
      - AND
      양쪽다 true를 가지고 있느면 결과값으로 true를       돌려준다 (하나라도 false면 결과값이 false이다.)
      - OR
      하나라도 true를 가지고 있으면 결과값으로 true
      를 돌려준다!(양쪽다 false면 결과값이 false이다.)
- 삼항 연산자 (조건 연산자)
 ? :
(조건식) ? 실행문1 : 실행문2
실행문1은 조건식이 true일 경우 실행되는 코드
실행문2는 조건식이 false일 경우 실행되는 코드

조건식 : 결과값으로 t/f를 돌려주는 연산자와 피연산자가
합쳐진 구조

변수
연산자
제어문 
1) 조건문 - if, ifelse, elseif, switch - case
2) 반복문 - for, while, do- while
이중 제어문
배열(자료구조) - 게임
이차원배열
메서드
OOP
상속추상인터페이스
JDBC

// 1) 입력하는 도구 가져오기
      
      // 2) 나이를 입력받아서 age라는 변수에 저장하기
      
      // 3) 사용자로부터 입력받은 나이가 20이상인지 확인하기
      // 단, 조건을 만족하면 "성인입니다"를 출력하고 아니면
      // 그냥 PASS !
package 단순if문;

import java.util.Scanner;

public class Ex01단순if문 {

   public static void main(String[] args) {

      // 제어문 
      // 컴파일 방향을 개발자가 원하는 방향으로 제어하기 위한 문법
      
      // 1) 조건문
      // : 조건식(예/아니오)에 따라서 만족하면 실행시키고 만족하지
      //   않으면 다음코드로 넘어갈 수 있도록 하는 문법
      
      // if, if-else, elseif, switch-case
      
      // 단순 if문의 문법 구조
      // if(조건식){ 조건식이 true일 경우, 실행시킬 코드 }
      
      // 조건식 : 결과값으로 boolean자료형을 돌려주는 식
      // (비교연산식, 논리연산식, boolean)
      
      
      // 정수를 입력받아 20보다 크거나 같으면 "성인입니다."
      // 라고 출력하는 프로그램을 만들어 보세요
      
      // 1) 입력하는 도구 가져오기
      Scanner sc = new Scanner(System.in);
      // 2) 나이를 입력받아서 age라는 변수에 저장하기
      System.out.print("나이 입력 : ");
      int age = sc.nextInt();
      // 3) 사용자로부터 입력받은 나이(age)가 20이상인지 확인하기
      // 단, 조건을 만족하면 "성인입니다"를 출력하고 아니면
      // 그냥 PASS !
      
      // 프로그래밍 언어에서 판단 ----> 조건식(문)
      if(age >= 20) {
         System.out.println("성인입니다.");
      }

      
   }

}

package 단순if문;

import java.util.Scanner;

public class Ex02단순if문 {

   public static void main(String[] args) {

      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      // 2) int num이라는 변수 선언하기
      int num;
      // 3) 사용자가 입력한 값으로 num을 초기화 하기
      num = sc.nextInt();
      // 4) 입력받은 num이 3의 배수, 5의 배수 '둘 다'
      // 만족 한다면, "3과 5의 배수입니다." 출력하기
      // - 두 조건이 다 만족하는지를 확인하려면 && 연산자 
      
      
      if(num%3==0 && num%5==0) {
         System.out.println("3과 5의 배수입니다.");
      }
      
   }

}


package if_else문;

import java.util.Scanner;

public class Ex01if_else문 {

   public static void main(String[] args) {

      // if-else문
      // : 조건식의 참/거짓에 대한 실행코드를 작성해보자
      
      // if(조건식){조건식이 true일 경우 동작하는 실행코드}
      // else{조건식이 false일 경우 동작하는 실행코드}
      
      // ctrl + a : 전체선택
      // ctrl + shift + f : 코드정리
      
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      // 2) 출력문으로 정수 입력 : 보여주기
      // 단, 오른쪽에 입력받을 수 있게 만들려면? println vs print
      System.out.print("정수 입력 : ");
      // 3) 사용자로부터 숫자 입력받기 
      // 입력받은 숫자는 num이라는 변수에 담아주기(저장)
      int num = sc.nextInt();
      // 4) num이 홀수인지 짝수인지 판별해서 짝수라면 "짝수입니다"
      //    홀수라면 "홀수입니다"를 출력하기
      // - 2로 나누었을 때 나머지가 0인지 아닌지 
      if(num % 2 == 1) {
         System.out.println("홀수 입니다.");
      }else {
         System.out.println("짝수 입니다.");
      }
      
      

      
      
   }

}

// 마트 계산대 프로그램
      // 만원짜리 추석선물 세트를 구입했을 때 지불해야하는
      // 금액을 계산해 보아요
      // 단, 11개 이상 구매시에는 10% 할인이 됩니다
      
      // 1) 입력하는 기능 가져오기
      
      // 2) 출려문이 보이는데 입력은 아래에서 받음
      // println vs print
      
      // 3) 상품의 개수 입력받아서 cnt라는 변수에 저장하기
      
      // 4) 상품의 개수가 11개 이상인지 판단하기
      // 11개 이상이면, 10% 할인해주기
      // 아니면 원가로 계산하기




package if_else문;

import java.util.Scanner;

public class Ex02if_else문 {

   public static void main(String[] args) {

      // 마트 계산대 프로그램
      // 만원짜리 추석선물 세트를 구입했을 때 지불해야하는
      // 금액을 계산해 보아요
      // 단, 11개 이상 구매시에는 10% 할인이 됩니다
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      // 입력하는 기능을 자연쌤이 맨날 첫번째 코드로 작성한 이유!
      // - 15행에 있는 코드가 실행되기 이전까지는 sc를 사용할 수가 없다!
      // 프로그램에서 사용하는 기능들을 import하는 코드는 항상
      // 맨 상단으로 올려놓고 코드작성을 진행하자!
      
      
      // 2) 출려문이 보이는데 입력은 아래에서 받음
      // println vs print
      System.out.println("사려는 상품의 갯수를 입력하세요");
      // 3) 상품의 개수 입력받아서 cnt라는 변수에 저장하기
      int cnt = sc.nextInt();
      // 4) 상품의 개수가 11개 이상인지 판단하기
      // 11개 이상이면, 10% 할인해주기
      // 아니면 원가로 계산하기
      // 소수점의 결과값이 나오지 않도록 만들어주기!
      
      // 가격이 저장될 수있는 변수
      int price = 10000;
      
      if(cnt >= 11) {
         // 10% 할인
         price = (int)(price * cnt * 0.9);
      }else {
         // 원가
         price = price * cnt;
         // price *= cnt
      }
      
      System.out.println("가격은"+price+"입니다.");
      
      
      
   }

}


// 학점계산 프로그램 만들기
      
      // 1) 입력하는 기능 가져오기
      
      // 2) totalScore 선언하기
      
      // 3) 사용자가 입력한 값으로 totalScore 초기화하기
      
      // 4) totalScore값을 판단하기 
      // 90점이상 - A
      // 80점이상 - B
      // 70점이상 - C
      // 70점미만 - D
      // 조건이 4가지이므로 else if 문을 사용해서 문제를 
      // 해결해 보자!

package elseif문;

import java.util.Scanner;

public class Ex02elseif문 {

   public static void main(String[] args) {

      // 학점계산 프로그램 만들기
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      System.out.print("점수 입력 : ");
      // 2) totalScore 선언하기
      int totalScore;
      // 3) 사용자가 입력한 값으로 totalScore 초기화하기
      totalScore = sc.nextInt();
      // 4) totalScore값을 판단하기 
      // 90점이상 - A
      // 80점이상 - B
      // 70점이상 - C
      // 70점미만 - D
      // 조건이 4가지이므로 else if 문을 사용해서 문제를 
      // 해결해 보자!
      if(totalScore >= 90) {
         System.out.println("A학점 입니다.");
      }else if(totalScore >= 80) {
         System.out.println("B학점 입니다.");
      }else if(totalScore >= 70) {
         System.out.println("C학점 입니다.");
      }else {
         System.out.println("D학점 입니다.");
      }
      
      
      
   }

}





package elseif문;

import java.util.Scanner;

public class Ex03elseif문 {

   public static void main(String[] args) {

      // 조건문
      // 1) 조건식을 사용해서 판단
      // 2) 조건문 안에 조건문을 넣어서 판단
      
      // 정보처리기사 합격 기준에 합격인지 불합격인지 판단
      
      // 1) 입력하는 기능가져오기
      Scanner sc = new Scanner(System.in);
      // 2) 출력문 + 입력문 *5
      // 5과목에 대해서 맞힌 개수를 입력받아보자
      // 그리고 각각 a,b,c,d,e 라는 변수에 저장해보자
      System.out.print("1과목 : ");
      int a = sc.nextInt();
      System.out.print("2과목 : ");
      int b = sc.nextInt();
      System.out.print("3과목 : ");
      int c = sc.nextInt();
      System.out.print("4과목 : ");
      int d = sc.nextInt();
      System.out.print("5과목 : ");
      int e = sc.nextInt();
      
      // 3) 합격/불합격 여부를 출력
      // - 합격 : 과락x, 평균 12개이상 맞혀야한다
      // - 불합격 : 과락o, 평균 12미만일 경우....
      if(a<8 || b<8 || c<8 || d<8 || e<8) {
         System.out.println("불합격입니다.");
      }else if(a+b+c+d+e >= 60) {
         System.out.println("합격입니다.");
      }else {
         System.out.println("불합격입니다.");
      }
      
      
   }

}



package switch_case문;

public class Ex01switch문 {

   public static void main(String[] args) {

      // ctrl + / : 선택 영역 전체 주석 달아주는 단축키
//      switch(변수) {
//      case 값1 :
//         변수랑 값1이 같으면 실행시킬 코드
//         break;
//         - switch-case문을 빠져나가는 키워드
//         실행코드를 동작하고나서 빠져나가고 싶으면 반드시
//         break키워드를 작성해줘야한다
//      }
      
      // 짝수/홀수를 구분
      int num = 5;
      // () : 변수, 식(결과값)
      switch(num%2) {
      case 1:
         System.out.println("홀수입니다.");
         break;
      case 0: 
         System.out.println("짝수입니다.");
         break;
      }
      // () : 변수, 식, 값
      
      switch(num) {
      case 1:
         System.out.println("1입니다.");
         break;
      case 2:
         System.out.println("2입니다.");
         break;
      case 5: 
         System.out.println("5입니다.");
         break;
      default:
         // 모든 경우를 만족하지 않았을 때에 
         // 실행시킬 코드를 작성 (else 비슷한 역할)
      }
      

   }

}


import java.util.Scanner;

public class Ex00자판기프로그램 {

   public static void main(String[] args) {

      // 자판기 프로그램
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);

      // 2) 출력문
      System.out.println("금액을 입력하세요.");
      int price = sc.nextInt(); // 내가 현재 가지고 있는 금액
      
      // 3) 메뉴판
      System.out.println("메뉴를 고르세요.");
      System.out.print("1.아우터(700원) 2.이구동성(1000원) 3.에그몽(500원) >> ");
      int select = sc.nextInt();
      // 입력받은 메뉴 번호가 뭔지 판단이 이루어 져야한다.
      
      if(select == 1) {
         
         if(price < 700) {
            System.out.println("돈이부족해요 ㅠㅠ");
         }else {
            price = price - 700;
         }
         
         
      }else if(select == 2) {
         
         if(price < 1000) {
            System.out.println("돈이 부족해요 ㅠㅠ");
         }else {
            price = price - 1000;
            // price -= 1000
         }
         
         
      }else {
         if(price < 500) {
            System.out.println("돈이 부족해요 ㅠㅠ");
         }else {
            price -= 500;
         }
         
      }
      
      System.out.println("잔돈 : "+price+"원");
      
      
      
      
      
   }
0
}


import java.util.Scanner;

public class Ex00자판기프로그램 {

   public static void main(String[] args) {

      // 자판기 프로그램
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);

      // 2) 출력문
      System.out.println("금액을 입력하세요.");
      int price = sc.nextInt(); // 내가 현재 가지고 있는 금액
      
      // 3) 메뉴판
      System.out.println("메뉴를 고르세요.");
      System.out.print("1.아우터(700원) 2.이구동성(1000원) 3.에그몽(500원) >> ");
      int select = sc.nextInt();
      // 입력받은 메뉴 번호가 뭔지 판단이 이루어 져야한다.
      
      if(select == 1) {
         
         if(price < 700) {
            System.out.println("돈이부족해요 ㅠㅠ");
         }else {
            price = price - 700;
         }
         
         
      }else if(select == 2) {
         
         if(price < 1000) {
            System.out.println("돈이 부족해요 ㅠㅠ");
         }else {
            price = price - 1000;
            // price -= 1000
         }
         
         
      }else {
         if(price < 500) {
            System.out.println("돈이 부족해요 ㅠㅠ");
         }else {
            price -= 500;
         }
         
      }
      // 잔돈이 price에 재할당 되어있는 ㄴ상태
      
      System.out.println("잔돈 : "+price+"원");
      System.out.print("천원 : "+price/1000+"개,");
      System.out.print("오백원 : "+price%1000/500+"개, ");
      System.out.print("백원 : "+price%500/100+"개");
      
      
   }

}


package for문;

public class Ex01for문 {

   public static void main(String[] args) {

      // 1) for문을 사용하여 21에서 57까지 출력하시오.
      for(int i = 21; i < 58; i++) {
         System.out.print(i+" ");
      }
      System.out.println(); // 개행
      
      // 2) for문을 사용하여 96에서 53까지 출력하시오.
      for(int i = 96; i >= 53; i--) {
         // i : 96 95 ..... 53
         System.out.print(i+" ");
      }
      // 3) for문을 사용하여 21에서 57까지의 수 중
      //    홀수만 출력하시오.
      System.out.println();
      // - 보폭(반복후작업)조정
      for(int i = 21; i <=57; i+=2) {
         // i : 21 23 25 27 .......
         System.out.print(i+" ");
      }
      // - 홀수인가를 판단해서 맞으면 출력한다
      System.out.println();
      // build up
      for(int i = 21; i <=57 ; i++) {
         if(i % 2 == 1) {
            System.out.print(i+" ");
         }
      }
      
      
      
      
      
      
      // 각 문제의 답은 오른쪽으로 출력되도록 만들어주자
      
      
   }

}.


package for문;

import java.util.Scanner;

public class Ex02for문 {

   public static void main(String[] args) {

      // 1) 1~100까지의 수 중에서 3의 배수만 출력하세요
      
      for(int i = 1; i <= 100; i++) {
         if(i % 3 == 0) {
            System.out.print(i +" ");
         }
      }
      
      System.out.println();
      
      
      // 2) 1~100까지 중 3의 배수이면서 5의 배수를 출력하세요
      
      for(int i = 1; i <= 100; i++) {
         if(i % 3 ==0 && i % 5 ==0) {
            System.out.print(i+" ");
         }
         // if문은 실행코드가 한 줄이면 중괄호 생략이 가능
      }
      
      // 3) 한 개의 자연수를 입력받아 그 수의 배수를 
      //    차례대로 10개 출력하는 프로그램을 작성하시오
      
      // console
      // 자연수를 입력하세요 : 5
      // 5  10  15  20  25  30  35  40  45  50
      
      // 1) 입력하는 도구 가져오기
      Scanner sc = new Scanner(System.in);
      // 2) 사용자로부터 자연수 입력받기
      System.out.print("자연수를 입력하세요 : ");
      int num = sc.nextInt();
      
      System.out.println(num*1);
      System.out.println(num*2);
      System.out.println(num*3);
      System.out.println(num*4);
      System.out.println(num*5);
      System.out.println(num*6);
      System.out.println(num*7);
      System.out.println(num*8);
      System.out.println(num*9);
      System.out.println(num*10);
      
      
      for(int i = 1; i <= 10; i++) {
         System.out.print(num*i+" ");
      }
      
      
      
      
      
   }

}


package for문;

import java.util.Scanner;

public class Ex03for문 {

   public static void main(String[] args) {

      // 입력받은 정수의 약수를 구하세요.
      Scanner sc = new Scanner(System.in);
      System.out.print("정수 입력 : ");
      int num = sc.nextInt();
      
      // 총합이 저장될 수 있는 변수
      int sum = 0; 
      
      // 만약에 8의 약수를 구한다고 했을 때
      for(int i = 1; i <= num/2; i++) {
         if(num % i == 0) {
            // System.out.print(i+" ");
            sum = sum + i;
         }
      }
      System.out.println();
      // 약수의 총합을 구하는 for을 작성해보자
      System.out.println("총합 : "+sum+num);
      
      // clean code라는 건 뭐지?
      // - 코드의 길이가 짧다
      // - 유지보수가 용이하다
      // - 가독성이 뛰어나다
      // - 시간복잡도가 줄어든 코드이다
      // : 실행시간
      
      
   
   }

}



for문은 반복문의 일종
반복 횟수가 정해져 있을 경우에 사용하는 문법

   시작점     도착점      보폭
for(초기화 구문; 조건식; 반복후작업){
   조건식이 true일동안 실행시킬 코드
}
for(int i = 1; i < 3; i++){
   syso(i);
}
console : 1 2




제어문 - 조건문
제어문 : 컴파일러의 방향을 개발자가 원하는데로 제어 할 수 있도록 도와주는 문법

- 조건문 : 조건식의 결과에 따라 코드를 실행시키는 문법
*조건식 : 결과값으로 boolean 자료형을 갖는 식
1) 단순 if문 : 참
if(조건식){조건식이 true일 경우 실행시킬 코드}
2) if-else문 : 참/거짓
if(조건식){조건식이 true일 경우 실행시킬 코드}
else{조건식이 false일 경우 실행시킬 코드}
3) if-elseif - else문 : 조건이 3개이상일 경우 
if(조건식1){조건식1이 true일 경우 실행시킬 코드}
else if(조건식2){조건식2이 true일 경우 실행시킬 코드}
else{위에 조건이 다 만족하지 않을 경우 실행시킬 코드}
4) switch-case문
switch(식, 변수, 값){
case 값1 : 
   값과 값1이 같으면 실행시킬 코드;
   break;
   // switch문을 빠져나가는 키워드입니다.
default :
   모든 case를 만족하지 않을때 실행시킬 코드
}




package while문;

import java.util.Scanner;

public class Ex02while문 {

   public static void main(String[] args) {

   
      // 입력 받은 수가 10보다 작을 때만
      // 계속 정수를 입력 받으세요.
      
      // 종료조건 : 사용자가 10보다 큰수를 입력하면
      //          while문을 빠져 나간다
      // 판단 - 조건식
      
      // 1) 입력하는 도구 가져오기 
      Scanner sc = new Scanner(System.in);
      
      // 2) 
      
      while(true) {
         System.out.print("정수 입력 : ");
         int num = sc.nextInt();
         
         // 사용자가 입력한 숫자가 
         // 10보다 큰 수인지 아닌지 판단
         if(num > 10) {
            System.out.println("종료되었습니다.");
            break;
         }
         
         
      }
      
   
   
   }

}



package while문;

import java.util.Scanner;

public class Ex03while문 {

   public static void main(String[] args) {

      // 숫자를 입력 받아 누적하는 프로그램을 작성하세요.
      // 단, -1을 입력한 경우 프로그램 종료
      
      // 종료조건 : 사용자가 -1을 입력하면 반복 종료
      // -1을 입력해도 누적결과는 보여진다.그리고 나서 종료
      
      // 1) 입력하는 기능가져오기 
      Scanner sc = new Scanner(System.in);
      
      // 2) 
      int sum = 0;
      // - sum이 while문 안에 초기화 되어있으면
      // 계속해서 0으로 초기화 되기 때문에 반복 안에서 
      // 영향을 받지 않도록 while문 밖으로 빼준다.
      while(true) {
         
         System.out.print("숫자 입력 : ");
         int num = sc.nextInt();
         
         
         // 사용자가 입력한 숫자들의 총합
         sum += num;
         System.out.println("누적결과 : "+sum);
         
         // 3) 종료조건
         // 사용자가 입력한 값(num) == -1
         if(num == -1) {
            System.out.println("종료되었습니다.");
            break;
         }
         
      }
      
      
      
      
   }

}




package while문;

import java.util.Scanner;

public class Ex05예제 {

   public static void main(String[] args) {

      // 종료조건
      // : 사용자가 -1을 입력하면 종료한다
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      
      // + 짝수, 홀수의 개수를 저장하는 변수
      int 짝수 = 0;
      int 홀수 = 0;
      
      do {
         System.out.print("숫자입력:");
         int num = sc.nextInt();
         // num : 홀수인지 짝수인지 판단
         
         // 종료조건 : num이 -1과 같으면 while문 종료
         // -1을 입력하면 홀수/짝수의 개수는 출력하지 않고
         // 바로 while문을 빠져나가기 때문
         if(num == -1) {
            System.out.println("종료되었습니다.");
            break;
         }
         
         if(num % 2 == 0) {
            ++짝수;
         }else {
            ++홀수;
         }
         
         System.out.println("짝수개수:"+짝수);
         System.out.println("홀수개수:"+홀수);
         
         
      }while(true);
      
      
      
      
      
      
   }

}]





package while문;

import java.util.Scanner;

public class Ex06예제 {

   public static void main(String[] args) {

      // 현재 몸무게와 목표 몸무게를 입력 받고 주차 별 
      // 감량 몸무게를 입력 받으세요
      
      // 목표 몸무게를 달성하면 축하한다는 문구를 출력하고
      // 입력을 멈추세요
      
      // 종료조건 : 현재 몸무게가 목표 몸무게 보다
      //          작거나 같으면 종료!
      
      // 현재 몸무게에서 감량몸무게를 뺀게 
      // 나의 현재 몸무게가 된다!
      
      // 현재 몸무게 : now
      // 목표 몸무게 : goal
      // 감량 몸무게 : minus
      // 주차 : week
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      
      // 2) 현재 몸무게를 입력
      System.out.print("현재 몸무게 : ");
      int now = sc.nextInt();
      // 3) 목표 몸무게를 입력
      System.out.print("목표 몸무게 : ");
      int goal = sc.nextInt();
      // 4) 주차를 표현할 수있는 변수
      int week = 1;
      
      while(true) {
         
         System.out.print(week+"주차 감량 몸무게 : ");
         int minus = sc.nextInt();
         
         week++;
         
         now = now - minus;
         // now -= minus;
         
         // 감량 몸무게를 빼고나서 혹시 현재몸무게가
         // 목표 몸무게에 도달하지는 않았는지 판단
         if(now <= goal) {
            System.out.println(now+"kg 달성!");
            break;
         }
         
      }
      
      
   }

}



package while문;

public class Ex07예제 {

   public static void main(String[] args) {

      // 숫자, 문자한개(char)의 같다를 비교할떄
      // : ==
      
      // 문자열이 같다를 비교할 때는
      // : equals()
      
      String name = "조자연";
      // name == "조자연"
      // name.equals("조자연")
      if(name.equals("조자연")) {
         System.out.println("로그인 성공");
      }
      
      // 입력하는 기능에서 문자열을 입력하는 건
      // : sc.next();
      
      
      
   }

}



package while문;

import java.util.Scanner;

public class Ex07예제 {

   public static void main(String[] args) {

      // Hello, 1234 - 로그인 성공
      // 로그인 실패
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      
      
      while(true) {
         // 2) 아이디랑 비밀번호를 입력
         System.out.print("아이디를 입력해 주세요 >> ");
         String id = sc.next();
         System.out.print("비밀번호를 입력해 주세요 >> ");
         int pw = sc.nextInt();
         // 3) id, pw가 로그인 성공인지 아닌지 판단
         if(id.equals("Hello") && pw == 1234) {
            System.out.println("로그인 성공!");
            break;
         }else {
            System.out.println("아이디와 비밀번호가 잘못되었습니다.");
         }
      }
      
      
      
      
      
      
      
      
      
   }

}



package while문;

import java.util.Scanner;

public class Ex07예제 {

   public static void main(String[] args) {

      // Hello, 1234 - 로그인 성공
      // 로그인 실패
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      
      // 로그인 실패 카운트하는 변수
      int cnt = 0;
      
      while(true) {
         // 2) 아이디랑 비밀번호를 입력
         System.out.print("아이디를 입력해 주세요 >> ");
         String id = sc.next();
         System.out.print("비밀번호를 입력해 주세요 >> ");
         int pw = sc.nextInt();
         // 3) id, pw가 로그인 성공인지 아닌지 판단
         if(id.equals("Hello") && pw == 1234) {
            System.out.println("로그인 성공!");
            break;
         }else {
            
            
            // 로그인 실패를 카운트하는 어떤 변수가 +1
            cnt++;
            // 계속할껀지는 로그인 실패 횟수가 3보다 작을 때만 물어보자
            // 만약 3보다크면 출려문, break;
            // 계속 할껀지 ? - y/n - String
            if(cnt < 3) {
               // 로그인에 실패
               System.out.println("아이디와 비밀번호가 잘못되었습니다.");
               // 시도할 수 있는 기회가 남아있는 상태
               System.out.print("계속 하시겠습니까? (Y/N)");
               String select = sc.next();
               if(select.equals("N")) {
                  System.out.println("종료되었습니다.");
                  break;
               }else {
                  continue;
                  // while문 처음으로 돌아가는 키워드
               }
            }else {
               // 로그인 실패를 3회 이상 했을 때
               System.out.println("아이디와 비밀번호가 3회 틀렸습니다. 본인인증을 해주세요");
               break;
            }
            
            
            
            // 사용자가 y를 입력했는지 n을 입력했는지를 판단
            // n을 입력했으면
            // - 종료했습니다.
            // while문을 빠져나가는 키워드 break;
            
            
         }
      }
      
      
      
      
      
      
      
      
      
   }

}




package while문;

import java.util.Scanner;

public class Ex08예제 {

   public static void main(String[] args) {
      
      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      // 2) 두수를 입력받고 연산자를 선택하고 결과를 보여주고
      //    다시 실행할 건지를 물어보는게 반복
      
      while(true) {
         
         // 3) 정수 입력 
         System.out.print("첫 번째 정수를 입력하세요 >> ");
         int num1 = sc.nextInt();
         // 4) 정수 입력
         System.out.print("두 번째 정수를 입력하세요 >> ");
         int num2 = sc.nextInt();
         // 5) 연산자 선택
         // - 더하기, 빼기
         System.out.print("[1]더하기 [2]빼기 >> ");
         int select1 = sc.nextInt();
         // 6) 선택에 따른 결과 보여주기
         if(select1 == 1) {
            System.out.println("더하기 연산 결과는"+(num1+num2)+"입니다.");
         }else {
            System.out.println("빼기 연산 결과는 "+(num1-num2)+"입니다.");
         }
         // 7) 다시 실행 여부 물어보기
         // - y/n을 입력받기 : n을 입력받으면 종료
         System.out.print("다시 실행하시겠습니까? (Y/N)");
         String select2 = sc.next();
         
         if(select2.equals("N")) {
            System.out.println("종료합니다.");
            break;
         }else {
            continue;
            // while문 옆에 조건식을 
            // 확인하지 않고 처음으로 돌아가서 바로 실행
         }
      
      }
      
      
      
      
   }
   
}



package while문;

import java.util.Random;
import java.util.Scanner;

public class Ex09예제 {

   public static void main(String[] args) {

      // 1) 필요한 기능 가져오기
      // - 랜덤, 입력
      Random rd = new Random();
      Scanner sc = new Scanner(System.in);
      
      // 2) 문제를 보여주자!
      // - 랜덤한 두 숫자를 출력해보자 (1 ~ 10)
      // 그치만.. 나중에 실제 정답을 구하려면 랜덤한 두 숫자는
      // 저장이 되어져야한다! num1과 num2에 담아주자
      System.out.println("==== Plus Game ====");
      
      while(true) {
         int num1 = rd.nextInt(10)+1; // 0-9
         int num2 = rd.nextInt(10)+1;
         // 나중에 사용자가 입력한 정답이랑 실제 정답을 비교
         System.out.print(num1+"+"+num2+"=");
         int answer = sc.nextInt();// 정답을 입력
         if(num1+num2 == answer) {
            System.out.println("Success");
         }else {
            System.out.println("Fail");
            System.out.print("계속 하시겠습니까? >> ");
            String str = sc.next();
            
            if(str.equals("N")) {
               System.out.println("종료합니다.");
               break;
            }else {
               continue;
            }
         }
      }
   

      // 4) 실제 정답과 사용자가 입력한 정답을 비교해보자
      // 만약에 정답을 맞추면 다시 문제를 보여주고
      // 틀렸으면 다시 실행할껀지 물어보자
      // - N이면 종료 , Y는 다시 문제를 보여주자!
      
   }

}



package 이중for문;

public class Ex01구구단 {

   public static void main(String[] args) {

      
      // 2단 ~ 9단 이중 for문을 사용해서 출력
      
      // build up!
      // 2단 for문을 사용해서 출력
      
      for(int j = 2; j <= 9; j++) {
         System.out.print("2단 : ");
         for(int i = 1; i <= 9; i++) {
            System.out.print("2*"+i+"="+2*i+" ");
         }
         System.out.println();
      }
      
      
      
      // 3단 for문을 사용해서 출력
      System.out.print("3단 : ");
      for(int i = 1; i <= 9; i++) {
         System.out.print("3*"+i+"="+3*i+" ");
      }
      System.out.println();
      
      // 4단 for문을 사용해서 출력
      System.out.print("4단 : ");
      for(int i = 1; i <= 9; i++) {
         System.out.print("4*"+i+"="+4*i+" ");
      }
      System.out.println();
      
      
   }

}





package 이중for문;

public class Ex00 {

   public static void main(String[] args) {

   
      for(int j = 0; j < 5; j++) {
         // *****
         // j : 0 1 2 3 4 (5번)
         for(int i = 0; i < 5; i++) {
            // i : 0 1 2 3 4
            System.out.print("*");
         }
         System.out.println();
      }
      
   
      
      
      
      
   }

}



for(int j = num; j >= 1; j--) {
         // j : 1 2 3 4 5 6 7
         //     7 6 5 4 3 2 1
         for(int i = 1; i <= j; i++) {
            System.out.print("*");
         }
         System.out.println();
      }



for(int j = 1; j <= num; j++) {
         // j : 1 2 3 4 5 6 7
         //     7 6 5 4 3 2 1
         for(int i = 1; i <= num+1-j; i++) {
            System.out.print("*");
         }
         System.out.println();
      }



v배열
같은 자료형의 데이터들을 하나의 묶음로 관리하기위한 자료구조

배열 선언 및 생성
자료형[] 배열명 = new 자료형[배열의 크기];
배열명 주소값
배열의 인덱스값을 통해 접근을 해야 실제 저장되어있는 데이터를 확인할 수있다......


package 일차원배열;

public class Ex01배열개념 {

   public static void main(String[] args) {

      // 배열의 필요성
      String b1 = "양준영";
      String b2 = "방상제";
      String b3 = "김지호";
      String b4 = "김창민";
      String b5 = "조자연";
      // 5명의 학생이름을 for문을 사용하면 출력할 수 있지 않을까?
      
      // 변수를 만드는건 서로 다른 공간이 5개가 생기것! (흩어져있음)
      // for문을 사용한 순차적인 접근은 불가능하게 만들어짐
      
      // 이름을 관리하는 배열을 만들어 주자
      // 1) 배열을 생성하는 방법
      // 자료형[] 배열명 = new 자료형[배열의크기];
      // 자료형 : 내가 배열에 저장하고 싶은 데이터들의 타입
      // [] --> 배열을 의미
      // new --> 동적 메모리를 새롭게 할당 해주는 키워드
      // 배열을 생성할 때는 뒤쪽에서 반드시 크기를 정해줘야한다
      
      String[] names = new String[5];
      // - 배열은 인덱스 구조를 가지고 있다
      System.out.println(names);
      // names : 레퍼런스형 변수(주소값을 참조하는 변수)
      
      // 기본 데이터 타입이 저장되는 방법 (boolean, int, doulbe, char..)
      // 레퍼런스형 데이터 타입이 저장되는 방법 (String, 배열)
      
      names[1] = b1;
      names[2] = b2;
      names[3] = b3;
      names[4] = b4;
      names[0] = b5;
      // ArrayIndexOutofBoundsException : 예외상황
      // - 실행을 시켜야 알 수있는 에러
      // - 인덱스 값이 초과/ 없는 인덱스 값에 접근
      // index 기본적으로 0부터 시작한다....
      // names가 가질 수있는 인덱스 값은 0 ~ 4
      
      // 인덱스를 변수로 사용/for문을 사용해서 names배열에 
      // 저장되어있는 이름 5개를 출력해보자!
      for(int i = 0; i <= 4; i++) {
         System.out.println(names[i]);
      }
      
      // 학생수가 증가해요... 
      // names[5] = "한재옥";
      // 앞에서 배열을 생성할 때 정해놓은 크기를 뒤에서 바꿀 수 없다...
      
  
      
      
      
   }

}



package 일차원배열;

public class Ex02배열 {

   public static void main(String[] args) {

      // 배열을 임의의 값으로 초기화
      // 3, 7, 18, 71, 9, 12, 24
      // (1차원 정수형 배열 - arr)
      
      // 배열의 값 중 홀수인 값이 몇 개인지 출력하는 프로그램을 작성하세요.
      
      int[] arr = {3, 7, 18, 71, 9, 12, 24};
      // arr 배열은 정수형 데이터를 저장하고 크기가 7인 배열
      
      // 홀수의 개수를 저장하는 변수
      int cnt = 0;
      
      System.out.print("array에 들어있는 홀수는 ");
      for(int i = 0; i < arr.length; i++) {
         if(arr[i] % 2 == 1) {
            // 홀수임
            System.out.print(arr[i]+" ");
            cnt++;
         }
      }
      System.out.println("이며,");
      System.out.println("총 "+ cnt+"개 입니다.");
      
      
      
      
      
   }

}



package 일차원배열;

public class Ex03배열 {

   public static void main(String[] args) {

      // arr 배열에서 최대값과 최소값을 구해보자
      // int i = 0;
      int[] arr = {23,45,95,17,6,89,47,56,68,71};
      // arr.length : 10
      // index : 0 ~ 9
      
      // 최대값/최소값이 저장될 수 있는 변수
      int max = arr[0];
      int min = arr[0];
      
      
      for(int i = 0; i < arr.length; i++) {
         // i : 0 1 2 3 4 5 6 7 8 9
         if(max < arr[i]) {
            max = arr[i];
         }
      }
      
      for(int i = 0; i < arr.length; i++) {
         // i : 0 1 2 3 4 5 6 7 8 9
         if(min > arr[i]) {
            min = arr[i];
         }
      }
      
      // - {} scope(영역)
      // - 지역변수 : 특정 구역에서만 사용할 수 있도록 선언 및 초기화
      // - 전역변수
      
      System.out.println("최대값 : "+max);
      System.out.println("최소값 : "+min);
      

   }

}



package 일차원배열;

import java.util.Scanner;

public class Ex04배열 {

   public static void main(String[] args) {

      Scanner sc = new Scanner(System.in);
      
      // 1) 점수가 저장 될 수 있는 배열 선언 및 생성
      // 크기 : 5, int , score
      int[] score = new int[5];
      
      // score라는 배열에는 현재 0이라는 값만 들어가있는 상태
      
      // 2) score[0] ~ score[4] = sc.nextInt()
      for(int i = 0; i<score.length; i++) {
         System.out.print(i+1+"번째 입력 >>");
         score[i] = sc.nextInt();
      }
      
//      System.out.print("2번째 입력 >>");
//      score[1] = sc.nextInt();

      // 3) 입력된 값을 한 번 출력
      System.out.print("입력된 점수 : ");
      for(int i = 0; i < score.length; i++) {
         System.out.print(score[i]+" ");
      }
      // 4) 최대/최소값 출력
      int max = score[0];
      int min = score[0];
      int sum = 0;
      
      for(int i = 0; i < score.length; i++) {
         if(max < score[i]) {
            max = score[i];
         }
         if(min > score[i]) {
            min = score[i];
         }
         sum += score[i];
      }
      System.out.println(max);
      System.out.println(min);
      System.out.println(sum);
      System.out.println(sum/score.length);
      // 5) 총합, 평균 출력
      
      
      
   }

}



package 일차원배열;

import java.util.Scanner;

public class Ex05배열 {

   public static void main(String[] args) {

      // 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      
      // 배열 선언 및 생성
      int[] arr = new int[10];
      
      // 사용자가 입력한 값으로 각각의 인덱스 초기화
      for(int i = 0; i < arr.length; i++) {
         // i : 0 1 2 3 4 5 6 7 8 9
         System.out.print(i+1+"번째 정수 입력 >> ");
         arr[i] = sc.nextInt();
      }
      System.out.print("3의 배수 : ");
      for(int i = 0; i < arr.length; i++) {
         if(arr[i] % 3 == 0) {
            System.out.print(arr[i]+" ");
         }
      }
      
      
      
      
      
      
      
      
      
      
      
   }

}




package 일차원배열;

import java.util.Random;

public class Ex06배열 {

   public static void main(String[] args) {

      // 로또 문제 : 중복 값 없이 배열에 랜덤한 값으로
      //           초기화 될 수있게 만들어 보자!
      
      // 랜덤한 값이 인덱스로 들어오면 이전에 인덱스에 
      // 들어있는 값들 중에서 중복되는 건(같은 것)없는지
      // 확인을 해보자!
      
      // 근데? 중복된값을 만나면 다시 현재 위치(인덱스)에서
      // 다른 값이 들어오도록 만들자!
      
      
      Random rd = new Random();
      int[] lotto = new int[5];
      
      for(int j = 0; j < 5; j++) {
         // 0번 인덱스에 값을 할당
         lotto[j] = rd.nextInt(10)+1;
         // 이전에 인덱스에 같은 값이 있는지 확인
         for(int i = 0 ; i < j; i++) {
            if(lotto[j] == lotto[i]) {

               j--;
               
            }
         }
      }
      
      
      for(int i = 0; i < lotto.length; i++) {
         System.out.print(lotto[i]+" ");
      }
      
      
      
      
//      // 1번 인덱스에 값을 할당
//      lotto[1] = rd.nextInt(10)+1;
//      // 0번 인덱스의 값과 같은지 확인
//      for(int i = 0; i < 1; i++) {
//         // i : 0
//         if(lotto[1] == lotto[i]) {
//            // 다시 1번인덱스에 값을 할당할 수 있도로 코드
//         }
//      }
//      // 2번 인덱스에 값을 할당
//      lotto[2] = rd.nextInt(10)+1;
//      // 0, 1번 인덱스의 값과 같은지 확인
//      for(int i = 0; i < 2; i++) {
//         if(lotto[2] == lotto[i]) {
//            // 다시 2번인덱스에 값을 할당할 수 있도로 코드
//         }
//      }
//      
//      // 3
//      lotto[3] = rd.nextInt(10)+1;
//      for(int i = 0; i < 3; i++) {
//         // i : 0 1 2
//         if(lotto[3] == lotto[i]) {
//            // 다시 2번인덱스에 값을 할당할 수 있도로 코드
//         }
//      }
//      
//      lotto[4] = rd.nextInt(10)+1;
//      for(int i = 0; i < 4; i++) {
//         // i: 0 1 2 3
//         if(lotto[4] == lotto[i]) {
//            // 다시 4번인덱스에 값을 할당할 수 있도록 코드
//         }
//      }
//      
//      
      
      
      
      
   
   }

}














package 일차원배열;

import java.util.Scanner;

public class Ex07배열 {

   public static void main(String[] args) {

      // 1) 입력하는 도구 가져오기
      Scanner sc = new Scanner(System.in);
      // 2) 별의 개수 5개를 저장할 수 있는 배열
      int[] stars = new int[5];
      
      for(int i = 0; i < stars.length; i++) {
         // i 0 1 2 3 4 (5번 반복)
         System.out.print(i+1+"번째 별의 개수를 입력 >> ");
         stars[i] = sc.nextInt();
      }
      
      // 3 3 4 2 1
      for(int j = 0; j < stars.length; j++) {
         System.out.print(stars[j]+" : ");
         for(int i = 1; i <= stars[j]; i++) {
            System.out.print("*");
         }System.out.println();
      }
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
   }

}



      // 1) 입력하는 기능 가져오기
      
      // 2) 실제 정답이 저장될 배열 만들기 - answer
      
      // 3) 사용자가 입력한 정답이 저장될 배열 만들기 - user
      
      // 4) 사용자로부터 정답 입력받기
      // 입력한 5개의 정답이 user배열 인데스에 저장 되어야함
      
      // 5) 사용자가 입력한 정답과 실제 정답이 같은지 비교하기
      // 정답이 같으면 'O'를 출력하고 총점에 +20하기
      // 정답이 다르면 'X'를 출력하기
      
      // - 총점이 계산되려면 총점이 저장될 수 있는 공간이
      //   필요하겠죠?

package 일차원배열;

import java.util.Scanner;

public class Ex08배열 {

   public static void main(String[] args) {

      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      // 2) 실제 정답이 저장될 배열 만들기 - answer
      int[] answer = {1, 4, 3, 2, 1}; // 크기 5
      // 3) 사용자가 입력한 정답이 저장될 배열 만들기 - user
      int[] user = new int[5];
      // 4) 사용자로부터 정답 입력받기
      // 입력한 5개의 정답이 user배열 인데스에 저장 되어야함
      
      for(int i = 0; i < user.length; i++) {
         // i : 0 1 2 3 4 
         System.out.print(i+1+"번답 >> ");
         user[i] = sc.nextInt();
      }
      
      // 5) 사용자가 입력한 정답과 실제 정답이 같은지 비교하기
      // 정답이 같으면 'O'를 출력하고 총점에 +20하기
      // 정답이 다르면 'X'를 출력하기
      int sum = 0; // 총합이 저장 변수
      
      for(int i = 0; i < user.length; i++) {
         // i : 0 1 2 3 4
         if(answer[i] == user[i]) {
            System.out.print("O ");
            // 총합 +20
            sum += 20;
         }else {
            System.out.print("X ");
         }
      }
      
      System.out.println("총합 : "+sum);
      
      
      // - 총점이 계산되려면 총점이 저장될 수 있는 공간이
      //   필요하겠죠?
      
      
   }

}


package 일차원배열;

import java.util.Scanner;

public class Ex09로그인프로그램 {

   public static void main(String[] args) {

      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      // 2) while문 사용해서 사용자한테 메뉴 선택 받기
      while(true) {
         // 종료조건 : 사용자가 3을 입력했을 때
         System.out.print("[1]회원가입 [2]로그인 [3]종료 >> ");
         int select = sc.nextInt();
         
         if(select == 1) {
            // 회원가입
            System.out.println("== 회원가입 ==");
         }else if(select == 2) {
            // 로그인
            System.out.println("== 로그인 ==");
         }else {
            System.out.println("프로그램이 종료되었습니다.");
            break; // while문을 빠져나가는 키워드
         }
         
         
      }
      
      
      
   }

}


// 1) id,pw가 저장될 수 있는 배열을 만들어보자
            // 배열을 만들어야하는 위치는 여기가 맞을까?도 고민해보세요
            
            // 2) 사용자가 입력한 id,pw가 각각의 인덱스값에
            // 저장될 수 있도록 만들어보자
            
            // - 근데 while문에서는 인덱스값으로 사용할 수 있는
            // 변수가 없음... 필요하면 만들어보아요
            
            // 아무래도 크기가 3으로 정해져있으니...
            // 3명을 초과하는 가입자가 발생하면 안됩니다!
            // 만약 초과하려고 했을 때는 ?
            // + "더 이상 가입할 수 없습니다." 문구를 보여주기



// 1) 사용자로 부터 id,pw을 입력받기
            
            // 2) 사용자가 입력한 id랑 pw가 배열에 들어있는지
            // 확인하기 
            // 단, 로그인 성공의 기준은...
            // id와 pw가 일치해야한다... 
            
            // id[0] - smhrd, id[1] - cjy
            // pw[0] - 1234,  pw[1] - 0000
            // 이 들어가있다고 가정했을 때
            // smhrd, 1234는 로그인 성공인데
            // smhrd, 0000은 로그인 실패입니다!




// 회원가입
            if(index == 3) {
               System.out.println("회원가입을 진행할 수 없습니다.");
               continue;
            }
            System.out.println("== 회원가입 ==");
            // 1) id,pw가 저장될 수 있는 배열을 만들어보자
            // 배열을 만들어야하는 위치는 여기가 맞을까?도 고민해보세요
            // -> while문이 실행될때마다 다시 초기화 되지 않도록 하기위해 바깥
            
            // 2) 사용자가 입력한 id,pw가 각각의 인덱스값에
            // 저장될 수 있도록 만들어보자
            System.out.print("아이디 입력 : ");
            String id = sc.next();
            System.out.print("비밀번호 입력 : ");
            int pw = sc.nextInt();
            
            // - 근데 while문에서는 인덱스값으로 사용할 수 있는
            // 변수가 없음... 필요하면 만들어보아요
            
            id_array[index] = id;
            pw_array[index] = pw;
            
            index++;
            // 다음 회원가입을 진행하는 사용자는 +1 증가한
            // 인덱스값에 데이터를 저장할 수 있도록
            
            // 아무래도 크기가 3으로 정해져있으니...
            // 3명을 초과하는 가입자가 발생하면 안됩니다!
            // 만약 초과하려고 했을 때는 ?
            // + "더 이상 가입할 수 없습니다." 문구를 보여주기






package 일차원배열;

import java.util.Scanner;

public class Ex09로그인프로그램 {

   public static void main(String[] args) {

      // 1) 입력하는 기능 가져오기
      Scanner sc = new Scanner(System.in);
      
      // id, pw 배열을 선언 및 생성
      String[] id_array = new String[3];
      int[] pw_array = new int[3];
      
      // 인덱스 값
      int index = 0;
      
      // 2) while문 사용해서 사용자한테 메뉴 선택 받기
      while(true) {
         // 종료조건 : 사용자가 3을 입력했을 때
         System.out.print("[1]회원가입 [2]로그인 [3]종료 >> ");
         int select = sc.nextInt();
         
         if(select == 1) {
            // 회원가입
            if(index == 3) {
               System.out.println("회원가입을 진행할 수 없습니다.");
               continue;
            }
            System.out.println("== 회원가입 ==");
            // 1) id,pw가 저장될 수 있는 배열을 만들어보자
            // 배열을 만들어야하는 위치는 여기가 맞을까?도 고민해보세요
            // -> while문이 실행될때마다 다시 초기화 되지 않도록 하기위해 바깥
            
            // 2) 사용자가 입력한 id,pw가 각각의 인덱스값에
            // 저장될 수 있도록 만들어보자
            System.out.print("아이디 입력 : ");
            String id = sc.next();
            System.out.print("비밀번호 입력 : ");
            int pw = sc.nextInt();
            
            // - 근데 while문에서는 인덱스값으로 사용할 수 있는
            // 변수가 없음... 필요하면 만들어보아요
            
            id_array[index] = id;
            pw_array[index] = pw;
            
            index++;
            // 다음 회원가입을 진행하는 사용자는 +1 증가한
            // 인덱스값에 데이터를 저장할 수 있도록
            
            // 아무래도 크기가 3으로 정해져있으니...
            // 3명을 초과하는 가입자가 발생하면 안됩니다!
            // 만약 초과하려고 했을 때는 ?
            // + "더 이상 가입할 수 없습니다." 문구를 보여주기
            
      
         }else if(select == 2) {
            boolean isSuccessful = false;
            
            // 로그인
            System.out.println("== 로그인 ==");
            
            // 1) 사용자로 부터 id,pw을 입력받기
            System.out.print("아이디 입력 : ");
            String id = sc.next();
            System.out.print("비밀번호 입력 : ");
            int pw = sc.nextInt();
            // 2) 사용자가 입력한 id랑 pw가 배열에 들어있는지
            // 확인하기 
            // 단, 로그인 성공의 기준은...
            // id와 pw가 일치해야한다... \
            for(int i = 0; i < id_array.length; i++) {
               if(id_array[i].equals(id) && pw_array[i]==pw) {
                  isSuccessful = true;
                  // 
               }
            }
            
            
            if(isSuccessful == true) {
               System.out.println("로그인 성공");
            }else {
               System.out.println("로그인 실패");
            }
            
            
            // id[0] - smhrd, id[1] - cjy
            // pw[0] - 1234,  pw[1] - 0000
            // 이 들어가있다고 가정했을 때
            // smhrd, 1234는 로그인 성공인데
            // smhrd, 0000은 로그인 실패입니다!
            
            // 회원가입이 3번 완료가 되어있어야 로직이 동작
            // NullPointerException...... 
            
            // 성공과 실패의 여부를 알 수있는 어떤 변수....?
            
            
         }else {
            System.out.println("프로그램이 종료되었습니다.");
            break; // while문을 빠져나가는 키워드
         }
         
         
      }
      
      
      
   }

}


package 이차원배열;

public class Ex02이차원배열 {

   public static void main(String[] args) {

      // 데이터의 입력방향
      // 00 10 20 30 40
      // 01 11 21 31 41
      // ...
      
      int[][] array = new int[5][5];
      
      int num = 21;
      
      for(int j = 0; j < array.length; j++) {
         // j : 0 1 2 3 4
         for(int i = 0; i < array.length; i++) {
            // i : 0 1 2 3 4
            array[i][j] = num;
            num++;
         }
      }
      
      // 데이터
      // 00 01 02 03 04 - 21 26 31 36 41
      // 10 11 12 13 14 - 22 27 32 37 42
      // ...
      
      for(int j = 0; j < array.length; j++) {
         for(int i = 0; i < array.length; i++) {
            System.out.print(array[j][i]+"\t");
         }System.out.println();
      }
      
      
      
      
      
   }

}
package 이차원배열;

public class Ex03이차원배열 {

   public static void main(String[] args) {

      int[][] array = new int[5][5];
      
      int num = 21;
      
      // 데이터 입력
      // 21 22 23 24 25 num
      // 04 14 24 34 44 index
      // 앞에 인덱스 값은 0 ~ 4 +1로 변하고 있음
      // 한 줄입력하고나서 뒤에 인덱스 값은 4 ~ 0 -1로 변함.
      
      for(int j = 4; j >= 0; j--) {
         // j : 4 3 2 1 0
         for(int i = 0; i < array.length; i++) {
            array[i][j] = num;
            num++;
         }
      }
      
      for(int j = 0; j < array.length; j++) {
         for(int i = 0; i < array.length; i++) {
            System.out.print(array[j][i]+ " ");
         }System.out.println();
      }
      
      
      
      
      
   }

}


package 이차원배열;

import java.lang.reflect.Array;

public class Ex04이차원배열 {

   public static void main(String[] args) {

      // 00 01 02 03 04 -> 21 - 25
      // 14 13 12 11 10 -> 26 - 30
      // 20 21 22 23 24 -> 31 - 35
      // 규칙!
      int[][] array = new int[5][5];

      int num = 21;
      // 0,2,4 -------->
      // 1,3   <--------

      for (int j = 0; j < 5; j++) {
         // j : 0 1 2 3 4
         if (j % 2 == 1) {
            // <----
            for(int i = 4; i >= 0; i--) {
               // i : 4 3 2 1 0 
               array[j][i] = num;
               num++;
            }
         } else {
            // ----> 0 1 2 3 4 
            for(int i = 0;  i < 5; i++) {
               array[j][i] = num;
               num++;
            }
         }

      }
      
      for(int j = 0; j < 5; j++) {
         for(int i = 0; i < 5; i++) {
            System.out.print(array[j][i]+" ");
         }System.out.println();
      }
      
      
      
      
      
      
      
      
      
      

   }
   
   
   

}




package 메서드;

public class Ex01매o리o {

   public static void main(String[] args) {

      // 매개변수 있고, 리턴타입(데이터 타입이 명시)이 있는 메서드
      minus(10,5);
      System.out.println(minus(10,5));
      
   }// main 밖 - 메서드 정의
   
   // 1) public : 공공의 
   // - 클래스 내/외부에서 자유로운 접근을 할 수 있도록 도와주는 제한자
   // (private, protected, default)
   // 2) static : 저장소
   // 메모리 공간이 굉장히 작기 때문에 함부러 사용하지 말 것!
   // 3) int : 리턴타입
   // 내가 메서드를 사용했을 때 돌려받는 결과값에 대한 데이터 타입
   // 4) 메서드명(호출명)
   // 5) 매개변수 
   // - 선언만
   // - 매개변수 이름은 구분할 수 있는 이름으로 지어주면 된다
   public static int minus(int num1, int num2) {
      // {} (body) == 메서드 로직
//      int result = num1 - num2;
//      return result;
      return num1 - num2;
      // return : 리턴타입에 데이터 타입이 명시되어있으면
      // 반드시 메서드 로직 안에 키워드가 포함되어있어야한다!
   }
   
   
   



package 메서드;

public class Ex05메서드실습 {

   public static void main(String[] args) {

      // 출력하는 기능을 가지고 있다 - void
      // 전달인자가 2개 - 매개변수 2개
      div(3,5);
      
   }

   public static void div(int num1, int num2) {
      System.out.println(num1/num2);
   }
   
   
}



package 메서드;

public class Ex06메서드실습 {

   public static void main(String[] args) {

      int num1 = 5;
      int num2 = 2;
      char op = '%'; // -, +, *, /
      
      System.out.println(cal(num1, num2, op));
      // op에 -가 있으면 num1과 num2를 빼기를 한 결과값
      
   }
   // cal 메서드를 만들어보자!
   // op에 따라서 돌려주는 결과값이 달라야 한다!
   
   public static int cal(int num1, int num2, char op) {
      // 전달인자 매개변수의 이름을 같은 이름을 주는 편
      // 나중에 어떤 데이터를 사용하는지 구분하기 위해서 
      int result = 0;
      
      if(op == '-') {
         //return num1 - num2;
         result =  num1 - num2;
      }else if(op == '+') {
         //return num1 + num2;
         result = num1 + num2;
      }else if(op =='*') {
         //return num1 * num2;
         result = num1 * num2;
      }else if(op == '/') {
         //return num1 / num2;
         result = num1/num2;
      }
      
      return result;
      // else문으로 닫아주는 작업
      // 모든 경우에 대해 돌아가는 결과값이 생길 수 있도록 
   }
   
   
   
   
   
   
   
   
   

}
}



int num1 = 10;
      int num2 = 24;
      int result = largerNumber(num1, num2);
      System.out.println("큰 수 확인 : " + result);




package 메서드;

public class Ex07메서드실습 {

   public static void main(String[] args) {

      int num1 = 10;
      int num2 = 10;
      int result = largerNumber(num1, num2);
      System.out.println("큰 수 확인 : " + result);
   
   }

   
   public static int largerNumber(int num1, int num2) {
      
      // num1, num2 누가 더 큰수 인지를 판단
      if(num1 > num2) {
         return num1;
      }else if(num2 > num1) {
         return num2;
      }else if(num1 == num2) {
         return 0;
      }else {
         return 0;
      }
      
      
      
      
   }
   
   
}



package 메서드;

public class Ex08완전수구하기 {

   public static void main(String[] args) {

      // isDivisor() : 약수인지 아닌지를 알려주는 메서드
      int num1 = 10;
      int num2 = 2;
      boolean divisor = isDivisor(num1, num2);
      
      System.out.println(divisor);
      // is ~ : 리턴타입이 boolean
      
      
      // 2) getDivisor(x) : 약수의 종류를 보여주는 메서드 
      
      getDivisor(10);
      getDivisor(16);
      getDivisor(24);
      
   }
   
   // 1) isDivisor() : 약수인지 아닌지 확인해주는 메서드
   // num2가 num1의 약수인지 아닌지 
   // == num1을 num2로 나누었을 때 나누어 떨어지는지
   public static boolean isDivisor(int num1, int num2) {
      
//      if(num1 % num2 == 0) {
//         return true;
//      }else {
//         return false;
//      }
      return num1%num2 == 0 ? true:false;
   }
   
   // 2) getDivisor(x) : 약수의 종류를 보여주는 메서드 
   public static void getDivisor(int num) {
      
      // 만약에 4
      for(int i = 1; i <= num; i++) {
         if(isDivisor(num, i)) {
            // num을 i로 나누었을 때 나누어 떨어지는지
            // i가 num의 약수인지 아닌지
            // isDivisor(num1, num2)
            // num2가 num1의 약수인지 아닌지
            // num1을 num2로 나우었을 때 나누어 떨어지는지
            System.out.print(i+" ");
         }
      }System.out.println();
      
   }
   
   
   

}


package 메서드;

public class Ex08완전수구하기 {

   public static void main(String[] args) {

      // isDivisor() : 약수인지 아닌지를 알려주는 메서드
      int num1 = 10;
      int num2 = 2;
      boolean divisor = isDivisor(num1, num2);
      
      System.out.println(divisor);
      // is ~ : 리턴타입이 boolean
      
      
      // 2) getDivisor(x) : 약수의 종류를 보여주는 메서드 
      
      getDivisor(10);
      getDivisor(16);
      getDivisor(24);
      
      int num = 10;
      int result = getSumOfDivisors(num);
      
      System.out.println(num+"의 약수의 합 : "+result);
      
      getDivisor(num);
      
      // 완전수란 무엇인가
      // : 나를 제외한 약수들의 합이 나와 같은 것
      // ex) 6 : 1 2 3 6
      // 6 == 6 : 완전수가 맞습니다.
      // ex) 28 : 1 2 4 7 14 28
      // 28 == 28 : 완전수가 맞습니다.
      // ex) 10 : 1 2 5 10
      // 8 == 10 : 완전수가 아닙니다.
      
      
      // 4) isPerfectNumber
      int num3 = 28;
      boolean result2 = isPerfectNumber(num3);
      System.out.println(result2); // true
      // 5) getPerfectNumber
      
   }
   
   // 1) isDivisor() : 약수인지 아닌지 확인해주는 메서드
   // num2가 num1의 약수인지 아닌지 
   // == num1을 num2로 나누었을 때 나누어 떨어지는지
   public static boolean isDivisor(int num1, int num2) {
      
//      if(num1 % num2 == 0) {
//         return true;
//      }else {
//         return false;
//      }
      return num1%num2 == 0 ? true:false;
   }
   
   // 2) getDivisor(x) : 약수의 종류를 보여주는 메서드 
   public static void getDivisor(int num) {
      
      // 만약에 4
      for(int i = 1; i <= num; i++) {
         if(isDivisor(num, i)) {
            // num을 i로 나누었을 때 나누어 떨어지는지
            // i가 num의 약수인지 아닌지
            // isDivisor(num1, num2)
            // num2가 num1의 약수인지 아닌지
            // num1을 num2로 나우었을 때 나누어 떨어지는지
            System.out.print(i+" ");
         }
      }System.out.println();
      
   }
   
   // 3) getSumOfDivisors(x) : 약수들의 합을 결과값으로 돌려주는 메서드
   public static int getSumOfDivisors(int num) {
      
      // num의 약수들의 합
      int sum = 0; 
      
      for(int i = 1; i <= num/2; i++) {
         if(isDivisor(num, i)) {
            sum += i;
         }
      }
      // 시간복잡도
      return sum+num;
   }
   
   // 4) isPerfectNumber
   // 나를 제외한 약수의 합이 나와같은지 확인해서 true/false를 돌려주자
   
   
   // 5) getPerfectNumber
 

}



            
      

package 메서드;

public class Ex08완전수구하기 {

   public static void main(String[] args) {

      // isDivisor() : 약수인지 아닌지를 알려주는 메서드
      int num1 = 10;
      int num2 = 2;
      boolean divisor = isDivisor(num1, num2);
      
      System.out.println(divisor);
      // is ~ : 리턴타입이 boolean
      
      
      // 2) getDivisor(x) : 약수의 종류를 보여주는 메서드 
      
      getDivisor(10);
      getDivisor(16);
      getDivisor(24);
      
      int num = 10;
      int result = getSumOfDivisors(num);
      
      System.out.println(num+"의 약수의 합 : "+result);
      
      getDivisor(num);
      
      // 완전수란 무엇인가
      // : 나를 제외한 약수들의 합이 나와 같은 것
      // ex) 6 : 1 2 3 6
      // 6 == 6 : 완전수가 맞습니다.
      // ex) 28 : 1 2 4 7 14 28
      // 28 == 28 : 완전수가 맞습니다.
      // ex) 10 : 1 2 5 10
      // 8 == 10 : 완전수가 아닙니다.
      
      
      // 4) isPerfectNumber
      int num3 = 28;
      boolean result2 = isPerfectNumber(num3);
      System.out.println(result2); // true
      // 5) getPerfectNumber
      
   }
   
   // 1) isDivisor() : 약수인지 아닌지 확인해주는 메서드
   // num2가 num1의 약수인지 아닌지 
   // == num1을 num2로 나누었을 때 나누어 떨어지는지
   public static boolean isDivisor(int num1, int num2) {
      
//      if(num1 % num2 == 0) {
//         return true;
//      }else {
//         return false;
//      }
      return num1%num2 == 0 ? true:false;
   }
   
   // 2) getDivisor(x) : 약수의 종류를 보여주는 메서드 
   public static void getDivisor(int num) {
      
      // 만약에 4
      for(int i = 1; i <= num; i++) {
         if(isDivisor(num, i)) {
            // num을 i로 나누었을 때 나누어 떨어지는지
            // i가 num의 약수인지 아닌지
            // isDivisor(num1, num2)
            // num2가 num1의 약수인지 아닌지
            // num1을 num2로 나우었을 때 나누어 떨어지는지
            System.out.print(i+" ");
         }
      }System.out.println();
      
   }
   
   // 3) getSumOfDivisors(x) : 약수들의 합을 결과값으로 돌려주는 메서드
   public static int getSumOfDivisors(int num) {
      
      // num의 약수들의 합
      int sum = 0; 
      
      for(int i = 1; i <= num/2; i++) {
         if(isDivisor(num, i)) {
            sum += i;
         }
      }
      // 시간복잡도
      return sum+num;
   }
   
   // 4) isPerfectNumber
   // 나를 제외한 약수의 합이 나와같은지 확인해서 true/false를 돌려주자
   // getSumOfDivisors(6) ---> 12
   // get(28) ---> 56
   // get(10) ---> 18
   
   // 5) getPerfectNumber
   
   // - isPerfectNumber를 사용하면 
   
   
   
   

}



package 메서드;

public class Ex08완전수구하기 {

   public static void main(String[] args) {

      // isDivisor() : 약수인지 아닌지를 알려주는 메서드
      int num1 = 10;
      int num2 = 2;
      boolean divisor = isDivisor(num1, num2);
      
      System.out.println(divisor);
      // is ~ : 리턴타입이 boolean
      
      
      // 2) getDivisor(x) : 약수의 종류를 보여주는 메서드 
      
      getDivisor(10);
      getDivisor(16);
      getDivisor(24);
      
      int num = 10;
      int result = getSumOfDivisors(num);
      
      System.out.println(num+"의 약수의 합 : "+result);
      
      getDivisor(num);
      
      // 완전수란 무엇인가
      // : 나를 제외한 약수들의 합이 나와 같은 것
      // ex) 6 : 1 2 3 
      // 6 == 6 : 완전수가 맞습니다.
      // ex) 28 : 1 2 4 7 14 28
      // 28 == 28 : 완전수가 맞습니다.
      // ex) 10 : 1 2 5 10
      // 8 == 10 : 완전수가 아닙니다.
      
      
      // 4) isPerfectNumber
      int num3 = 36;
      boolean result2 = isPerfectNumber(num3);
      System.out.println(result2); // true
      // 5) getPerfectNumber
      
      int start = 2;
      int end = 1000;
      getPerfectNumber(start, end);
      
      // - 출력하는 기능을 가지고 있다 (void)
      // - 전달인자 2개 (int) ---> 매개변수 2개(int)
      
   }
   
   // 1) isDivisor() : 약수인지 아닌지 확인해주는 메서드
   // num2가 num1의 약수인지 아닌지 
   // == num1을 num2로 나누었을 때 나누어 떨어지는지
   public static boolean isDivisor(int num1, int num2) {
      
//      if(num1 % num2 == 0) {
//         return true;
//      }else {
//         return false;
//      }
      return num1%num2 == 0 ? true:false;
   }
   
   // 2) getDivisor(x) : 약수의 종류를 보여주는 메서드 
   public static void getDivisor(int num) {
      
      // 만약에 4
      for(int i = 1; i <= num; i++) {
         if(isDivisor(num, i)) {
            // num을 i로 나누었을 때 나누어 떨어지는지
            // i가 num의 약수인지 아닌지
            // isDivisor(num1, num2)
            // num2가 num1의 약수인지 아닌지
            // num1을 num2로 나우었을 때 나누어 떨어지는지
            System.out.print(i+" ");
         }
      }System.out.println();
      
   }
   
   // 3) getSumOfDivisors(x) : 약수들의 합을 결과값으로 돌려주는 메서드
   public static int getSumOfDivisors(int num) {
      
      // num의 약수들의 합
      int sum = 0; 
      
      for(int i = 1; i <= num/2; i++) {
         if(isDivisor(num, i)) {
            sum += i;
         }
      }
      // 시간복잡도
      return sum+num;
   }
   
   // 4) isPerfectNumber
   // 나를 제외한 약수의 합이 나와같은지 확인해서 true/false를 돌려주자
   // getSumOfDivisors(6) ---> 12
   // get(28) ---> 56
   // get(10) ---> 18
   public static boolean isPerfectNumber(int num3) {
      
      boolean result = false;
      // 완전수라면 result를 true로 바꿔주자
      // getSumOfDivisors(num3) - num3 == num3
      if(getSumOfDivisors(num3)-num3 == num3) {
         result = true;
      }
      
      return result;
      
   }
   
   // 5) getPerfectNumber
   
   // - isPerfectNumber를 사용하면 
   public static void getPerfectNumber(int start, int end) {
      
      // start에서 end 사이에 있는 숫자들 중 완전수만 출력
      System.out.print(start+"~"+end+"까지의 완전수 : ");
      for(int i = start; i <= end; i++) {
         if(isPerfectNumber(i)) {
            System.out.print(i+" ");
         }
      }
      
      
//      if(isPerfectNumber(3)) {
//         System.out.print(3+" ");
//      }
//      if(isPerfectNumber(4)) {
//         System.out.print(4+" ");
//      }
      
   }
   
   
   

}


package 메서드;

public class Ex09Overloading {

   public static void main(String[] args) {

      // 한국인 이름을 데이터베이스에 저장하는 메서드 :
      // stName(성, 이름) -
      // stName("조","자연");

      stName("스티브", "폴", "잡스");
      stName("조", "자연");

      // 같은 기능을 하는 메서드들이 서로 다른 이름을 가지고 있으면
      // 개발자 입장에서 번거로운...
      // 코드의 길이가 줄어든다 if문으로 이사람이 미국인인지, 한국인인지
      // 구분할 필요가 없다!...

      // 오버로딩(중복정의) - Overloading
      // : 같은 클래스 내에서 같은 이름의 메서드를 정의 할 수 있다
      // 단, 매개변수의 형태가 달라야 한다(데이터 타입, 매개변수의 개수, 순서)
      
      // System.out.print(false);
      // 
      
   }

   public static void stName(int firstName, String lastName) {
      
   }

   public static void stName(String lastName, int firstName) {

   }

   public static void stName(String firstName, String lastName) {
      // 코드... 데이터베이스에 이름을 저장.......
   }

   public static void stName(String firstName, String middleName, String lastName) {
      // 코드... 데이터베이스에 이름을 저장.......
   }
}





main 밖
public : 접근제한자
static : 저장소
데이터타입, void :  리턴타입
--> 메서드를 통해 얻는 결과값(리턴값)의 데이터 타입
메서드명(호출명)

(매개변수)--> 모든 메서드들은 소괄호를 가지고 있다
매개변수 : 메서드 안에서 사용되는 변수로써 선언단만 작성
{} : 메서드 로직
로직 안쪽으로 return
1) 값을 호출한 곳으로 반환
2) 메서드 종료
리턴타입에 데이터 타입이 명시되어있으면 return 필수
void return 생략가능

사용(실행)
호출명(전달인자)
전달인자 == 매개변수
개수, 데이터타입, 순서

- 오버로딩(중복정의)
: 같은 클래스 내에서 같은 이름의 메서드를 만들 수 있다
단, 매개변수의 형태가 달라야한다
(데이터 타입, 매개변수의 개수, 순서)




package Person;

public class Person {

   // 설계도에 해당하는 곳
   // Class == 설계도
   // 1) Field(필드) : 데이터, 변수, 속성, 정보
   // 내가 설계하고자 하는 Object가 가질 수 있는 데이터
   //                (Person)
   
   // 사람이 가질 수 있는 데이터(변수)?
   // - 나이
   int age;
   // - 성별
   String gender;
   // - 이름
   String name;
   // 필드를 만들 때는 선언만 해준다...
   // 이름을 "조자연"으로 설계도에 만들어놓으면 이 설계도를 통해
   // 만들어지는 모든 사람들은 이름이 "조자연"
   
   // 2) Method(메서드) : Object의 행위/행동, 기능
   // 사람이 할 수 있는 행위/행동?
   
   // - 숨쉬기
   public void breathe() {
      System.out.println("숨을 쉰다 ㅇ3ㅇ ~ ");
   }
   // - 밥먹기
   public void eat() {
      System.out.println("밥을 먹는다 :q ~");
   }
   // - 잠자기
   public void sleep() {
      System.out.println("잠을 잔다 ㅡ_ㅡzz");
   }
   
   
   
}





package 저금통;

public class PiggyBank {

   // 저금통 설계도
   // 1) 필드 - 금액(돈)
   int money;
   // 2) 메서드 - 입금, 출금, 잔액
   public void withdraw(int money) {
      // 돈을 인출
      this.money -= money;
   }
   public void deposit(int money) {
      // 돈을 입금
      // this : 현재 클래스를 지칭 키워드
      this.money = this.money + money;
   }
   public void showMoney() {
      // 현재 내가 가지고있는 금액을 보여주는 기능
      System.out.println(money+"원");
   }
   
}





package 저금통;

public class PiggyBank {

   // 저금통 설계도
   // 1) 필드 - 금액(돈)
   private int money;
   // private : 필드를 클래스 외부에서 접근할 수 없도록 도와주는 제한자
   // private로 되어있는 필드는 존재하고있는 클래스 내부에 메서드를 통해서만
   // 접근이 가능하다
   
   // PiggyBank 클래스에 필드에 접근할 수 있는 메서드를 만들어줘야한다!
   // - 생성자(constructor)
   
   public PiggyBank(int money) {
      // - 기본 생성자 : 클래스를 만들때 생략되어있다.
      // 1. 객체 생성을 할 수 있다
      // 2. 필드를 초기화 시키는 기능을 가질 수 있다
      this.money = money;
   }
   
   // getter/setter
   // getter : 필드에 있는 데이터를 결과값으로 돌려주는 메서드
   // setter : 필드에 있는 값을 수정하고 싶을 때 사용하는 메서드 
   public int getMoney(){
      // 현재 필드에 있는 값을 결과로 돌려주면 됨...
      return money;
   }
   
   public void setMoney(int money) {
      // 매개변수 money : 어떤 값으로 수정할 건지 에대한 데이터
      this.money = money;
   }
   
   
   
   // 2) 메서드 - 입금, 출금, 잔액
   public void withdraw(int money) {
      // 돈을 인출
      this.money -= money;
   }
   public void deposit(int money) {
      // 돈을 입금
      // this : 현재 클래스를 지칭 키워드
      this.money = this.money + money;
   }
   public void showMoney() {
      // 현재 내가 가지고있는 금액을 보여주는 기능
      System.out.println(money+"원");
   }
   
}



package 저금통;

public class PiggyBank {

   // 저금통 설계도
   // 1) 필드 - 금액(돈)
   private int money;
   // private : 필드를 클래스 외부에서 접근할 수 없도록 도와주는 제한자
   // private로 되어있는 필드는 존재하고있는 클래스 내부에 메서드를 통해서만
   // 접근이 가능하다
   
   // PiggyBank 클래스에 필드에 접근할 수 있는 메서드를 만들어줘야한다!
   // - 생성자(constructor)
   
   public PiggyBank(int money) {
      // - 기본 생성자 : 클래스를 만들때 생략되어있다.
      // 1. 객체 생성을 할 수 있다
      // 2. 필드를 초기화 시키는 기능을 가질 수 있다
      this.money = money;
   }
   
   
   // 생성자의 특징 ❤️❤️❤️❤️❤️❤
   // 1. 생성자도 메서드 - ()
   // 2. 생성자는 리턴타입이 없다(void도 안와요)
   // 3. 기본생성자는 생략되어있다.
   // 4. 새로운 생성자를 내가 만들면
   //  필드를 초기화 시키는 생성자를 만들면
   //  기본생성자는 사용할 수 없는 상태가 된다...
   
   
   
   
   
   
   
   
   
   
   
   
   // getter/setter
   // getter : 필드에 있는 데이터를 결과값으로 돌려주는 메서드
   // setter : 필드에 있는 값을 수정하고 싶을 때 사용하는 메서드 
   public int getMoney(){
      // 현재 필드에 있는 값을 결과로 돌려주면 됨...
      return money;
   }
   
   public void setMoney(int money) {
      // 매개변수 money : 어떤 값으로 수정할 건지 에대한 데이터
      this.money = money;
   }
   
   
   
   // 2) 메서드 - 입금, 출금, 잔액
   public void withdraw(int money) {
      // 돈을 인출
      this.money -= money;
   }
   public void deposit(int money) {
      // 돈을 입금
      // this : 현재 클래스를 지칭 키워드
      this.money = this.money + money;
   }
   public void showMoney() {
      // 현재 내가 가지고있는 금액을 보여주는 기능
      System.out.println(money+"원");
   }
   
}

package 저금통;

public class PiggyBank {

   // 저금통 설계도
   // 1) 필드 - 금액(돈)
   private int money;
   private String name;
   
   // 클래스 외부에서 접근 할 수 없도록 
   // 단, 클래스 내부에 설계되어있는 메서드를
   // 통해서 접근이 가능하다
   
   // 생성자
   // - 객체 생성 (기본)
   // - 필드를 초기화 (만들어줘야하는 것)
   
   public PiggyBank() {
      // 기본 생성자
   }
   
   public PiggyBank(int money, String name) {
      this.money = money;      
      this.name = name;
   }
   
   // 1. 생성자도 메서드다
   // 2. 생성자의 이름은 설계도(클래스)의 이름과 같다
   // 3. 기본생성자는 생략되어잇다
   // 4. 내가 새로운생성자를 만들면 기본생성자는 사용을 못한다
   // 5. 기본 생성자도 사용하고 싶고, 필드를 초기화 시키는
   // 것도 사용하고 싶으면 오버로딩 해주면 됩니다
   // 오버로딩 : 
   // 6. 리턴타입이 없다(void도 안온다!)
   
   
   
   
   // getter/setter
   // getter - 필드를 가져와주는 역할 
   public int getMoney(){
      return money;
   }
   // setter - 필드를 수정하는 역할
   public void setMoney(int money) {
      this.money = money;
   }
   
   // 2) 메서드 - 입금, 출금, 잔액
   public void withdraw(int money) {
      // 돈을 인출
      this.money -= money;
   }
   public void deposit(int money) {
      // 돈을 입금
      // this : 현재 클래스를 지칭 키워드
      this.money = this.money + money;
   }
   public void showMoney() {
      // 현재 내가 가지고있는 금액을 보여주는 기능
      System.out.println(money+"원");
   }
   
}




package 저금통;

public class Main {

   public static void main(String[] args) {

      // 1) PiggyBank 설계도를 사용해서 객체생성
      // pig
   
      PiggyBank pig = new PiggyBank();
      // 2) pig에 money를 10000원으로 초기화 시키자
      // pig.money = 100000000;
      // 3) pig에 deposit이라는 기능을 사용해서
      // 5000원을 입금
      // 매개변수로 정수형 데이터 1개를 사용
      // 전달인자도 1개가 있다... 
      pig.deposit(5000);
      
      // 4) 잔액을 확인했을 때
      pig.showMoney();// 15000원
      
      // 5) 돈을 인출 - 1200원
      pig.withdraw(1200);
      
      // 6) 잔액 확인 
      pig.showMoney(); // 13800원
      
      // 7) getter를 사용해서 잔액을 확인해보자!
      System.out.println(pig.getMoney());
      
      // 8) setter를 사용해서 잔액을 18000원으로 바꿔보자!
      pig.setMoney(18000);
      pig.showMoney();
      
   }

}





package 학생정보관리프로그램;

public class Student {

   String name;
   String number;
   
   int age;
   int scoreJava;
   int scoreWeb;
   int scoreAndroid;
   
   public Student(String name, String number, int age,
         int scoreJava, int scoreWeb, int scoreAndroid) {
      this.name = name;
      this.number = number;
      this.age = age;
      this.scoreJava = scoreJava;
      this.scoreWeb = scoreWeb;
      this.scoreAndroid = scoreAndroid;      
   }
   
   public void show() {
      
      System.out.println(name+"님 안녕하세요.");
      System.out.println("[ "+number+", "+age+"살 ]");
      System.out.println(name+"님의 Java점수는 "+scoreJava+"점 입니다.");
      System.out.println(name+"님의 Web점수는 "+scoreWeb+"점 입니다.");
      System.out.println(name+"님의 Android점수는 "+scoreAndroid+"점 입니다.");
   
      
   }
   
   
   
   
   
   
   
   
   
   
   
}



package 학생정보관리프로그램;

public class Main {

   public static void main(String[] args) {

      Student student1 = new Student("나예호",
            "20200801", 20, 10, 80, 95);
      Student student2 = new Student("김운비",
            "20111003", 19, 90, 65, 30);
      
      student1.show();
      student2.show();
      
      
   }

}






package Person2;

public class Main {

   public static void main(String[] args) {

      // 1) 
      Person person1 = new Person();
      // 2) 
      person1.setName("홍길동");
      person1.setAge(25);
      // 3) 
      Person person2 = new Person("김영희", 27);
      // 4)
      System.out.println(person1.getName()+","+person1.getAge());
      System.out.println(person2.getName()+","+person2.getAge());
   
   }

}





package Person2;

public class Person {

   private String name;
   private int age;
   
   public Person() {
      // 기본 생성자
   }
   
   public Person(String name, int age) {
      this.name = name;
      this.age = age;
   }
   
   public String getName() {
      return name;
   }
   
   public void setName(String name) {
      this.name = name;
   }
   
   public int getAge() {
      return age;
   }
   
   public void setAge(int age) {
      this.age = age;
   }
   
   
   
   
   
   
   
   
}




package Calculator;

public class Calculator {

   
   private int num1;
   private int num2;
   
   // 1) 필드를 초기화 시키는 생성자
   public Calculator(int num1, int num2) {
      this.num1 = num1;
      this.num2 = num2;      
   }
   
   // 2) setter
   public void setNum1(int num1) {
      this.num1 = num1;
   }
   public void setNum2(int num2) {
      this.num2 = num2;
   }
   
   // 3) 일반 메서드
   
   public int sum() {
      return num1+num2;
   }
   public int sub() {
      return num1-num2;
   }
   public int mul() {
      return num1*num2;
   }
   public double div() {
      return num1/num2;
   }
   
   
   
   
   
}



package Calculator;

public class Main {

   public static void main(String[] args) {

      
      // 1) 
      Calculator cal = new Calculator(45, 50);
      // 2)
      // cal.sum();
      System.out.println(cal.sum());
      // 3) 
      cal.setNum1(75);
      cal.setNum2(5);
      
      
      // 4) 
      System.out.println(cal.sub());
      System.out.println(cal.mul());
      System.out.println(cal.div());
      
      
      
      
      
   }

}


package StudentScore;

public class StudentScore {

   private String name;
   private int scoreJava;
   private int scoreWeb;
   private int scoreAndroid;
   
   // alt + shift + s
   
   public StudentScore(String name, int scoreJava, int scoreWeb, int scoreAndroid) {
      // super(); - 상속
      this.name = name;
      this.scoreJava = scoreJava;
      this.scoreWeb = scoreWeb;
      this.scoreAndroid = scoreAndroid;
   }

   public String getName() {
      return name;
   }

   public int getScoreJava() {
      return scoreJava;
   }

   public int getScoreWeb() {
      return scoreWeb;
   }

   public int getScoreAndroid() {
      return scoreAndroid;
   }
   
   
   
   
   
}


package StudentScore;

import java.util.Scanner;

public class Main {

   public static void main(String[] args) {

      Scanner sc = new Scanner(System.in);
      
      // 1. StudentScore 자료형을 관리하는 배열생성하기
      // 크기는 3으로 이름은 score로 만들어주기
      StudentScore[] score = new StudentScore[3];      
      
      // 2. 값을 입력받아서 StudentScore를 초기화하기
      // 즉, 생성자를 사용해서 필드를 초기화를 진행하고
      // 사용자가 입력한 값을 전달인자로 사용하기
      // 이름이랑 3개의 점수를 사용자한테 입력받은 후
      // 4개의 입력받은 데이터를 
      // StudentScore라는 하나의 자료형으로 만들어주기!
      
      for(int i = 0; i < score.length; i++) {
         // i : 0 1 2
         System.out.print(i+1+"번째 학생의 이름을 입력하세요 >> ");
         String name = sc.next();
         System.out.print(i+1+"번째 학생의 Java점수를 입력하세요 >> ");
         int java = sc.nextInt();
         System.out.print(i+1+"번째 학생의 Web점수를 입력하세요 >> ");
         int web = sc.nextInt();
         System.out.print(i+1+"번째 학생의 Android점수를 입력하세요 >> ");
         int android = sc.nextInt();
         
         StudentScore stu = new StudentScore(name, java, web, android);
         score[i] = stu;
      }
      
      // 3. 2번에 해당하는걸 3번 진행해야함! - for문을 사용해서 반복
      // 0,1,2 인덱스에 사용자가 입력한 값이 각각 들어가줘야함
      
      // 4. 입력이 다 끝나고나면 for문을 사용해서 각각의 데이터를 출력
      // 0,1,2 인덱스에 저장되어있는건 주소값
      // 주소값을 참조해서 이름이랑 점수들을 출력해보자
      // (데이터를 가져와주는 기능은 없나? - getter가 만들어져있음)
      
      
      for(int i = 0; i < score.length; i++) {
         int sum = score[i].getScoreAndroid()+score[i].getScoreJava()+score[i].getScoreWeb();
         System.out.println(score[i].getName()+"님의 총점은 "
               +sum+"점,"
               +"평균은 "+sum/3+"입니다." );
      }
      
      
      
      
      
      
      
   }

}






package 책관리프로그램;

public class BookData {

   
   // 필드 3개
   private String title;
   private int price;
   private String writer;
   
   
   public BookData(String title, int price, String writer) {
      // super();
      this.title = title;
      this.price = price;
      this.writer = writer;
   }

   public String getTitle() {
      return title;
   }


   public int getPrice() {
      return price;
   }


   public String getWriter() {
      return writer;
   }
   
   // 메서드 4개
   // alt + shift + s
   
   
   
   
   
}



package 책관리프로그램;

import java.util.Scanner;

public class Main {

   public static void main(String[] args) {
      
      Scanner sc = new Scanner(System.in);
      
      
      // 1) BookData를 저장할 수 있는 배열을 5칸짜리로 선언 및 생성하기
      // - 이름은 books로 만들어주기
      BookData[] books = new BookData[5];
      // 2) BookData 객체 생성 진행하기 
      // - 이미지 2번 표에 있는 값으로 객체 생성 5번 진행하기
      // - 이름은 book1 ~ book5로 생성해주세요
      BookData book1 = new BookData("Java", 21000, "홍길동");
      BookData book2 = new BookData("C++", 29000, "박문수");
      BookData book3 = new BookData("Database", 31000, "김장독");
      BookData book4 = new BookData("Android", 18000, "이순신");
      BookData book5 = new BookData("Web", 26000, "김철수");
      // 3) book1 ~ book5를 배열에 담아주기
      books[0] = book1;
      books[1] = book2;
      books[2] = book3;
      books[3] = book4;
      books[4] = book5;
      
      // 4) 사용자로 부터 금액을 입력받기
      System.out.print("금액을 입력하세요 : ");
      int price = sc.nextInt();
      // 5) 입력받은 가격보다 저렴한 책을 books에서 찾아서 목록과
      //    가격을 출력하기 
      // - 이미지 3번에서 콘솔창과 같은 형태로 출력해주세요
      System.out.println("구매 가능한 책 목록");
      
      for(int i = 0; i < books.length; i++) {
         if(price >= books[i].getPrice()) {
            System.out.print("["+books[i].getTitle()+",");
            System.out.print(books[i].getWriter()+","+books[i].getPrice()+"]");
            
         }
      }
      
         
      
      package MusicPlayer;

public class Music {

   // 필드
   // 가수 : singer
   // 제목 : title
   // 플레이 시간 : playTime
   // 경로 : path
   private String singer;
   private String title;
   private int playTime;// 초단위 초기화
   private String path;
   
   // 생성자 : 4개의 매개변수를 가지는 생성자
   public Music(String path, String title, String singer, int playTime) {
      this.path = path;
      this.title = title;
      this.singer = singer;
      this.playTime = playTime;
   }

   public String getSinger() {
      return singer;
   }

   public String getTitle() {
      return title;
   }

   public int getPlayTime() {
      return playTime;
   }

   public String getPath() {
      return path;
   }
   
   // 4개 필드에대한 getter....
   
   
}



package MusicPlayer;

import java.util.ArrayList;
import java.util.Scanner;

import javazoom.jl.player.MP3Player;

public class Main {

   public static void main(String[] args) {

      // 1) 외부 라이브러리 적용하기 - player.jar
      
      MP3Player mp3 = new MP3Player();
      
      // mp3.play("C:\\Users\\user\\Desktop\\music\\Mena Massoud, Naomi Scott - A Whole New World.mp3");

      // 경로 + 파일명 + 확장자 : path
      // mp3.stop();
      
      // 노래 한곡
      // 가수, 노래제목, 플레이시간, 경로
      // -> Music
      
      
      // Music 클래스를 사용해서 10개의 객체생성을 진행해보자
      // music1 ~ music10
      
        String defaultPath = "C:\\Users\\user\\Desktop\\music\\";
        Music m1 = new Music(defaultPath + "Anne Marie - 2002.mp3", "2002", "Anne Marie", 257);
        Music m2 = new Music(defaultPath + "Billie Eilish - bad guy.mp3", "bad guy", "Billie Eilish", 277);
        Music m3 = new Music(defaultPath + "Carmen Twillie, Lebo M. - Circle of Life.mp3", "Circle of Life", "Carmen Twillie, Lebo M.", 257);
        Music m4 = new Music(defaultPath + "CHUNG HA - 벌써 12시.mp3", "벌써 12시", "CHUNG HA", 182);
        Music m5 = new Music(defaultPath + "Idina Menzel - Let It Go.mp3", "Let It Go", "Idina Menzel", 126);
        Music m6 = new Music(defaultPath + "Itzy - Dalla Dalla.mp3", "Dalla Dalla", "Itzy", 233);
        Music m7 = new Music(defaultPath + "JENNIE - SOLO.mp3", "SOLO", "JENNIE", 198);
        Music m8 = new Music(defaultPath + "Mena Massoud, Naomi Scott - A Whole New World.mp3", "Mena Massoud, Naomi Scott", "A Whole New World", 222);
        Music m9 = new Music(defaultPath + "Rain - 깡.mp3", "깡", "Rain", 237);
        Music m10 = new Music(defaultPath + "TWICE - FANCY.mp3", "FANCY", "TWICE", 114);

      
      // 1) Music 자료형을 관리하는 ArrayList를 하나 만들어주세요
      // musicList라는 이름으로 만들어주세요
      
        ArrayList<Music> musicList = new ArrayList<>();
        
      // 2) music1 ~ music10 ArrayList에 담아주기
      musicList.add(m1);
      musicList.add(m2);
      musicList.add(m3);
      musicList.add(m4);
      musicList.add(m5);
      musicList.add(m6);
      musicList.add(m7);
      musicList.add(m8);
      musicList.add(m9);
      musicList.add(m10);
      
      // System.out.println(musicList.get(0).getSinger());
      
      Scanner sc = new Scanner(System.in);
      
      while(true) {
         System.out.print("[1]재생 [2]정지 [3]이전곡 [4]다음곡 [5]종료 >> ");
         int select = sc.nextInt();
         if(select == 1) {
            // 노래 재생
         }else if(select == 2) {
            // 노래 정지
         }else if(select == 3) {
            // 노래 이전곡
         }else if(select == 4) {
            // 다음곡 재생
         }else {
            System.out.println("프로그램 종료");
            break;
         }
      }

   }

}


      
      
      
      
      
      
      
   }
   
}




package MusicPlayer;

import java.util.ArrayList;
import java.util.Scanner;

import javazoom.jl.player.MP3Player;

public class Main {

   public static void main(String[] args) {

      // 1) 외부 라이브러리 적용하기 - player.jar
      
      MP3Player mp3 = new MP3Player();
      Controller con = new Controller();
      // Controller에 만들어놓은 기능을 Main에서 가져다가 사용하려면
      // 객체생성이 이루어 져야한다!
      
      
      // mp3.play("C:\\Users\\user\\Desktop\\music\\Mena Massoud, Naomi Scott - A Whole New World.mp3");
      // mp3.play
      // 경로 + 파일명 + 확장자 : path
      // mp3.stop();
      
      // 노래 한곡
      // 가수, 노래제목, 플레이시간, 경로
      // -> Music
      
      
      // Music 클래스를 사용해서 10개의 객체생성을 진행해보자
      // music1 ~ music10
      
        String defaultPath = "C:\\Users\\user\\Desktop\\music\\";
        Music m1 = new Music(defaultPath + "Anne Marie - 2002.mp3", "2002", "Anne Marie", 257);
        Music m2 = new Music(defaultPath + "Billie Eilish - bad guy.mp3", "bad guy", "Billie Eilish", 277);
        Music m3 = new Music(defaultPath + "Carmen Twillie, Lebo M. - Circle of Life.mp3", "Circle of Life", "Carmen Twillie, Lebo M.", 257);
        Music m4 = new Music(defaultPath + "CHUNG HA - 벌써 12시.mp3", "벌써 12시", "CHUNG HA", 182);
        Music m5 = new Music(defaultPath + "Idina Menzel - Let It Go.mp3", "Let It Go", "Idina Menzel", 126);
        Music m6 = new Music(defaultPath + "Itzy - Dalla Dalla.mp3", "Dalla Dalla", "Itzy", 233);
        Music m7 = new Music(defaultPath + "JENNIE - SOLO.mp3", "SOLO", "JENNIE", 198);
        Music m8 = new Music(defaultPath + "Mena Massoud, Naomi Scott - A Whole New World.mp3", "Mena Massoud, Naomi Scott", "A Whole New World", 222);
        Music m9 = new Music(defaultPath + "Rain - 깡.mp3", "깡", "Rain", 237);
        Music m10 = new Music(defaultPath + "TWICE - FANCY.mp3", "FANCY", "TWICE", 114);

      
      // 1) Music 자료형을 관리하는 ArrayList를 하나 만들어주세요
      // musicList라는 이름으로 만들어주세요
      
        ArrayList<Music> musicList = new ArrayList<>();
        
      // 2) music1 ~ music10 ArrayList에 담아주기
      musicList.add(m1);
      musicList.add(m2);
      musicList.add(m3);
      musicList.add(m4);
      musicList.add(m5);
      musicList.add(m6);
      musicList.add(m7);
      musicList.add(m8);
      musicList.add(m9);
      musicList.add(m10);
      
      // System.out.println(musicList.get(0).getSinger());
      
      Scanner sc = new Scanner(System.in);
      
      // 현재 어떤노래가 재생인지 저장되는 변수 index
      int index = 0;
      
      while(true) {
         System.out.print("[1]재생 [2]정지 [3]이전곡 [4]다음곡 [5]종료 >> ");
         int select = sc.nextInt();
         if(select == 1) {
            // 노래 재생
            // console
            // 노래 제목 - 가수 이름, 4분 30초
            
            // 첫번째 노래가 재생될 수 있도로 만들어주자!
            mp3.play(musicList.get(index).getPath());
            
            // 출력문 현재 재생중인 노래에 대한 정보를 보여주자
//            System.out.print(musicList.get(index).getTitle()+"-");
//            System.out.print(musicList.get(index).getSinger()+",");
//            System.out.print(musicList.get(index).getPlayTime()/60+"분");
//            System.out.print(musicList.get(index).getPlayTime()%60+"초");
//            System.out.println();
            
            musicList.get(index).showMusic();
            
            
            
         }else if(select == 2) {
            // 노래 정지 - stop
            
            // musicStop();
            con.musicStop();
            // NullPointerException
            
         }else if(select == 3) {
            // 노래 이전곡
            
            // 현재 재생중인 노래가 있으면, 멈추고
            // isPlaying - 노래가 재생 : true, 멈춰 : false
            con.musicStop();
            // 현재 인덱스를 기준으로 -1에 위치해 있는 노래가 재생 되도록 만들자
            // 단, 첫번째 곡에서 (index가 0일때) 이전곡을 누르면
            // 마지막 곡이 실행될 수 있도록 만들자
            
            index = con.preMusic(index, musicList);         
            
            // 출력문 현재 재생중인 노래에 대한 정보를 보여주자
//            System.out.print(musicList.get(index).getTitle()+"-");
//            System.out.print(musicList.get(index).getSinger()+",");
//            System.out.print(musicList.get(index).getPlayTime()/60+"분");
//            System.out.print(musicList.get(index).getPlayTime()%60+"초");
//            System.out.println();
            musicList.get(index).showMusic();
            // 마찬가지로 곡이 실행될때 노래에 대한 정보가 출력되도록 만들자
            // 노래 제목 - 가수 이름, 4분 30초
            
         }else if(select == 4) {
            // 다음곡 재생
            
            // 현재 재생중인 노래가 있으면, 멈추고
            con.musicStop();
            
            index = con.nextMusic(index, musicList);
            
            // 출력문 현재 재생중인 노래에 대한 정보를 보여주자
//            System.out.print(musicList.get(index).getTitle()+"-");
//            System.out.print(musicList.get(index).getSinger()+",");
//            System.out.print(musicList.get(index).getPlayTime()/60+"분");
//            System.out.print(musicList.get(index).getPlayTime()%60+"초");
//            System.out.println();
            musicList.get(index).showMusic();
            
            // 현재 인덱스를 기준으로 +1에 위치해 있는 노래가 재생 되도록 만들자
            // 단, 마지막 곡에서 (index가 9일때) 다음곡을 누르면
            // 첫번째 곡이 실행될 수 있도록 만들자
            
            // 마찬가지로 곡이 실행될때 노래에 대한 정보가 출력되도록 만들자
            // 노래 제목 - 가수 이름, 4분 30초
         }else {
            System.out.println("프로그램 종료");
            break;
         }
      }
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
   }

}




package MusicPlayer;

import java.util.ArrayList;

import javazoom.jl.player.MP3Player;

public class Controller {

   MP3Player mp3 = new MP3Player();
   // 노래가 재생중인지 아닌지 확인 후 노래를 멈추는 기능
   // - musicStop() : void
   
   
   public void musicStop() {
      if(mp3.isPlaying()) {
         mp3.stop();
      }
   }
   
   // 이전곡을 재생하는 기능
   public int preMusic(int index, ArrayList<Music> musicList) {
      index--;
      if(index == -1) {
         index = musicList.size()-1;
      }
      mp3.play(musicList.get(index).getPath());
      
      return index;
      
   }
   
   public int nextMusic(int index, ArrayList<Music> musicList) {
      index++;
      // 9 10
      if(index == musicList.size()) {
         index = 0;
      }
      
      mp3.play(musicList.get(index).getPath());
   
      return index;
   
   }
   
   
   
   
   
}




package 마우스;

public class Main {

   public static void main(String[] args) {

      // BallMouse
      BallMouse mouse1 = new BallMouse();
      mouse1.drag();
      mouse1.leftClick();
      mouse1.rightClick();
      
      
   }

}

==== 객체지향프로그램 ====
: 각각의 기능을 클래스로 나눠서 구현
메세지를 통해서 데이터를 처리하는 기법

Class : 설계도
1) 필드 : 데이터, 변수, 속성
2) 메서드 : 행위/기능
 - 생성자, getter,setter
생성자 
기능 2가지 : 객체를 생성하는, 필드를 초기화 시키는 기능
- 생성자도 메서드다
- 리턴타입이 없다! (void도 안온다!)
- 기본생성자는 생략되어있구
만약에 내가 필드를 초기화 시키는 생성자를 새로 만들게 된다면
생략되어있던 기본생성자는 사용할 수 없는 상태가 된다!
둘다 사용하고 싶다면? - 오버로딩
기본생성자를 구현해준다면 둘다 사용할 수 있는 상태가 된다!
* 오버로딩 : 같은 클래스 내에서 같은 이름의 메서드를 정의 할 수 있다!
- 생성자의 이름은 클래스의 이름과 동일하다

getter/setter 
- 필드를 private 접근제한자를 사용해서 외부에서 접근할 수 없도록 만들줬다!
private : 클래스 외부에서 접근할 수 없는 제한자
클래스 내부에 설계되어있는 메서드를 통해서는 접근이 가능하다!
getter : get필드명()
데이터를 가져오는 메서드
setter : set필드명()
데이터를 수정할 수 있는 메서드

설계도를 사용하는 방법 - 실행
main메서드에서 설계도를 사용해보자!

클래스명  변수명 = new 클래스명(); --> 객체생성
Person p1 = new Person();
p1 :  주소값
주소값안에는 내가 설계도에 작성해놨던 필드, 메서드가 저장이 되어있다.
. <--- 참조 연산자

p1.필드
p1.메서드명

하나의 프로그램을위해 클래스가 여러개 만들어질 수 있다!
동물, 조류, 포유류, 파충류, 펭귄, 고래, 독수리

모든 동물들이 먹고, 자고, 성별, 움직인다.
클래스마다 다 구현하는게 아니라 최상위 동물 클래스에다가 모든 동물들이 가진 특징을 담아놓고 하위클래스에 물려주는 방법 : 상속

class 클래스명 extends 부모클래스명
현재클래스에서 부모 클래스에있는 필드, 메서드를 사용할 수 있는 상태

자식클래스의 기능이 부모클래스로인해 확장되기 때문에 extends라는 키워드를 사용한다. 

상속의 화살표 방향은
자식 -----> 부모 
이유 : 컴파일러가 데이터를 탐색해 나가는 방향을 상속의 화살표 방향으로 정의함

자식 클래스 : 서브 클래스
부모 클래스 : 수퍼 크래스
 --> super();

어차피 부모가 물려주는 기능을 자식에서 다시 구현을 한다면?
부모클래스에 기능이 {} 필요가 없어요.... 

public abstract void move();
추상 메서드
- 로직이 없는 메서드

Error - Class에서 
추상메서드를 포함하고 있는 클래스는 추상클래스가 되어야한다!
abstract class로 바꿔줘야합니다.

추상 클래스를 상속받고 있는 자식클래스에서 추상 메서드를 구현하지 않으면 에러가 발생
- 추상 메서드는 하위 클래스에서 구현을 강제화...
(1) 추상클래스로 바꾸거나
(2) 추상메서드를 구현..

추상 클래스는 객체 생성이 불가능하다
- 불완전한 설계도는 객체생성을 할 수 가 없다
- 추상 메서드를 포함하고 있을 수도 있기 때문에
* 추상 클래스라고 해서 무조건 추상메서드가 있는 건 아니에요




package 월급관리프로그램;

public class RegularEmployee {

   String empno;
   String name;
   int pay; 
   int bonus;
   
   
   public RegularEmployee(String empno, String name, int pay, int bonus) {
      // super();
      this.empno = empno;
      this.name = name;
      this.pay = pay;
      this.bonus = bonus;
   }
   
   // 월급여를 결과로 돌려주는 메서드
   public int getMoneyPay() {
      return (pay+bonus)/12;
   }
   // 사원의 정보를 결과값으로 돌려주는 메서드
   public String print() {
      return empno+":"+name+":"+pay;
   }

   
   
}



package 월급관리프로그램;

public class TempEployee {

   String empno;
   String name;
   int pay;
   
   public TempEployee(String empno, String name, int pay) {
      // super();
      this.empno = empno;
      this.name = name;
      this.pay = pay;
   }
   
   // 비정규직 직원의 월급여를 결과값으로 돌려주는 메서드
   public int getMoneyPay() {
      return pay/12;
   }
   
   // 사원의 정보
   public String print() {
      return empno+":"+name+":"+pay;
   }
   
   package 월급관리프로그램;

public class PartTimeEmployee {

   String empno;
   String name;
   int pay; // 일당
   int workDay; // 일수
   
   public PartTimeEmployee(String empno, String name, int pay, int workDay) {
      // super();
      this.empno = empno;
      this.name = name;
      this.pay = pay;
      this.workDay = workDay;
   }
   
   
   // 월 급여
   public int getMoneyPay() {
      return pay*workDay;
   }
   // 사원의 정보
   public String print() {
      return empno+":"+name+":"+pay;
   }
   
   
}


}



//JDBC
1.동적로딩: class.forname(_
2.DB연결권한확인
3.쿼리문 작성



package JDBC기초;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Scanner;

public class Ex01Insert {

   public static void main(String[] args) {

      // 사용자로 부터 이름, 나이, 성별, 학과를 입력받아서
      // 입력받은 내용이 데이터베이스에 저장 될 수 있도록 만들어 주자!
      Scanner sc = new Scanner(System.in);

      System.out.print("이름 : ");
      String name = sc.next();
      System.out.print("나이 : ");
      int age = sc.nextInt();
      System.out.print("성별 : ");
      String gender = sc.next();
      System.out.print("학과 : ");
      String major = sc.next();

      // 입력받은 4개의 데이터를 Student라는 하나의 자료형

      Student stu = new Student(name, age, gender, major);

      // 1. 동적 로딩 : 실행을 시키면 자료형이 결정되는 것
      try {
         Class.forName("oracle.jdbc.driver.OracleDriver");
         // 기울임꼴 형태의 코드 : static(정적인 공간을 사용하는)

         // Syntax Error (문법에러)
         // Exception (예외상황)

         // 2. 데이터 베이스 연결 권한 확인
         // 준비물 : id, pw, url
         String id = "hr";
         String pw = "12345";
         String url = "jdbc:oracle:thin:@localhost:1521:xe";

         // jdbc:oracle:thin - 오라클 thin 드라이버
         // @localhost - 나의 컴퓨터 ip주소를 가져와주는 키워드
         // 1521 : port 번호
         // xe : 오라클 db의 별명(별칭)

         Connection con = DriverManager.getConnection(url, id, pw);
         // DriverManager import 해주기
         // Connection import 해주기
   
         // con - 받아온 연결 권한
         
         // 3. 쿼리문을 준비하자
         String sql = "INSERT INTO STUDENT VALUES(?,?,?,?)";
         // ? : 사용자가 입력한값인데 내가 아직 사용자가 뭘 입력한지 모르기 때문
         
         PreparedStatement psmt = con.prepareStatement(sql);
         // import 작업하기 - db로 쿼리문을 가지고 이동하는 객체
         // ? 를 채우는 작업을 진행해보자
         
         psmt.setString(1, stu.getName());
         psmt.setInt(2, stu.getAge());
         psmt.setString(3, stu.getGender());
         psmt.setString(4, stu.getMajor());
         
         int cnt = psmt.executeUpdate();
         // executeUpdate : 쿼리문을 db로 이동시켜서 실행하고,
         // 결과값도 받아오는 기능을 가지고 있다.
         // 결과값은 테이블에 영향을 받은 행이 있는지 없는지에 대해서 int자료형의 값을 가져온다.
         
         if(cnt > 0) {
            System.out.println("추가 성공");
         }else {
            System.out.println("추가 실패");
         }
         
      } catch (ClassNotFoundException e) {
         e.printStackTrace();
         System.out.println("동적 로딩 실패");

         // OracleDriver
         // 1) ojdbc.jar 파일이 적용이 안되어있거나
         // 2) "" 경로가 잘못되었거나 - 오타

      }
      // try ~ catch ~ finally
      // : 예외상황을 처리하는 문법
      catch (SQLException e) {
         e.printStackTrace();
         System.out.println("권한 확인 실패");

         // - 나의 계정의 비밀번호나 아이디 오타 확인
         // - url의 값이 잘못된건 아닌지 오타 확인
         
      }

   }

}





package JDBC기초;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Scanner;

public class Ex02Update {

   public static void main(String[] args) {

      // Scanner를 사용해서 사용자한테 이름 나이를 입력받아서
      // 전공을 수정해보자
      Scanner sc = new Scanner(System.in);
      PreparedStatement psmt = null;
      Connection con = null;
      
      System.out.print("본인의 이름을 입력하세요 >> ");
      String name = sc.next();
      System.out.print("나이를 입력하세요 >> ");
      int age =  sc.nextInt();
      System.out.print("수정할 전공을 입력하세요 >> ");
      String major = sc.next();
      // Student 자료형을 사용해서 캡슐화를 진행해주시면 됩니다.
      // 생성자를 사용해서 필드 3개를 초기화 시켜주면 됩니다.
      Student stu = new Student(name, age, major);
      
      // JDBC 코드 - UPDATE STUDENT SET MAJOR = ? WHERE NAME = ? AND AGE = ?;
      
      
      // 1. 동적 로딩
      
      try {
         Class.forName("oracle.jdbc.driver.OracleDriver");
         // ojdbc11.jar에 있는 오라클 드라이버의 경로를 입력
         // 예외상황이 발생할 수 도 있는 코드는 try~catch문으로 감싸주자!
         
         // 2. 연결 권한 확인
         // - id, pw, url
         String id = "hr";
         String pw = "12345";
         String url = "jdbc:oracle:thin:@localhost:1521:xe";
         
         con = DriverManager.getConnection(url, id, pw);
         // DriverManager한테 id, pw, url 주면서 연결 권한 확인
         // - 연결 권한을 가지고 돌아온다
         // - con이라는 변수에 담아놓고 필요할 때 사용할 예정
         
         // 3. 쿼리문 준비하기
         String sql = "UPDATE STUDENT SET MAJOR = ? WHERE NAME = ? AND AGE = ?";
         
         /// 4. PreparedStatement에 쿼리문을 담아준다!
         psmt = con.prepareStatement(sql);
         // 연결권한을 사용해서 psmt에 쿼리문 담아주기!
         
         // + 채워줄 ? 인자가 있으면 채워주는 작업을 진행하자
         psmt.setString(1, stu.getMajor());
         psmt.setString(2, stu.getName());
         psmt.setInt(3, stu.getAge());
         
         int cnt = psmt.executeUpdate();
         // - 쿼리문을 데이터 베이스로 전송
         // - 데이터베이스에서 쿼리문을 실행
         // - 결과값도 받아오는 기능
         // 결과값 : 내가 만든 쿼리문으로 인해 영향을 받은 행이 있는지 없는지 int 자료형의 결과값
         // 1 : 영향을 받은 행이 있음 .. 쿼리문 실행에 성공
         // 0, -1 : 영향을 받은 행이 없음 .. 쿼리문 실행에 실패
         
         if(cnt > 0) {
            System.out.println("업데이트 성공");
         }else {
            System.out.println("업데이트 실패");
         }
         
      } catch (ClassNotFoundException e) {
         e.printStackTrace();
         System.out.println("동적 로딩 실패");
      } catch (SQLException e) {
         e.printStackTrace();
         System.out.println("연결 실패");
      }finally {
         
         // try ~ catch ~ finally
         // finally 안쪽에 작성되는 코드는 마지막에 무조건 한번은
         // 실행되는 코드가 들어온다!
         
         // 자원반납이 중간에 에러가 발생해도, try안에 있는 코드가
         // 다 실행 되더라도 마지막에 꼭 한번 실행될 수 있도록 
         
         // close();
         
         // - 내가 사용했던 자원을 역순으로 닫아줘야한다!
         // PreparedStatement ---> Connection
         
         try {
            // 사용된적이 있는 기능만 반납할 수 있도로 if문 추가
            if(psmt != null)
               psmt.close();
            if(con != null)
               con.close();
            // 실행코드가 1개면 중괄호 생략
         } catch (SQLException e) {
            e.printStackTrace();
            System.out.println("자원 반납 오류");
         }
         // try문 안에만 사용할 수 있도록 선언 및 초기화를 진행 했기 때문
      }
      
      
      
      package JDBC기초;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class Ex04Select {

   public static void main(String[] args) {

      // 실행시켰을 때 DB에 있는 전체 데이터를 조회할 수 있도록 만들어주자
      // - SELECT * FROM STUDENT;
      Connection con = null;
      PreparedStatement psmt = null;
      
      // 1. 동적 로딩
      try {
         Class.forName("oracle.jdbc.driver.OracleDriver");
         
         // 2. 데이터 베이스 연결 권한 확인
         String id = "hr";
         String pw = "12345";
         String url = "jdbc:oracle:thin:@localhost:1521:xe";
         
         con = DriverManager.getConnection(url, id, pw);
         
         
      } catch (ClassNotFoundException e) {
         e.printStackTrace();
         System.out.println("동적 로딩 실패");
         // - ojdbc11.jar
         // - 경로 오타!
      } catch (SQLException e) {
         e.printStackTrace();
         System.out.println("연결 실패");
      }
      
      
      
      
      
      
   }

}

      
      
      
      
      
      
      
   }

}





package 학생정보관리프로그램;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class StudentDAO {

   // dto를 데이터베이스에 저장하는 - 학생등록
   public int insert(StudentDTO dto) {
      
      // 사용자가 입력했었던
      // name, age, gender, major - dto에 들어있는 상태
      
      Connection conn = null;
      PreparedStatement psmt = null;
      int cnt = 0;
      // jdbc 코드
      // 1. 동적 로딩
      try {
         Class.forName("oracle.jdbc.driver.OracleDriver");
         
            // 2. 데이터 베이스 연결 권한 확인
            String id = "hr";
            String pw = "12345";
            String url = "jdbc:oracle:thin:@localhost:1521:xe";
            
            conn = DriverManager.getConnection(url, id, pw);
            
            String sql = "INSERT INTO STUDENT VALUES(?,?,?,?)";
            psmt = conn.prepareStatement(sql);
            // - ? 인자 채워주는 작업
            psmt.setString(1, dto.getName());
            psmt.setInt(2, dto.getAge());
            psmt.setString(3, dto.getGender());
            psmt.setString(4, dto.getMajor());
            // dto에 사용자 입력했었던 데이터가 담겨있으므로
            
            cnt = psmt.executeUpdate();
            // cnt가 데이터베이스랑 연결하고나서 받아온 결과값
            // cnt를 View한테 어떤 값인지를 알려줘야겠다.            
            
      } catch (ClassNotFoundException e) {
         e.printStackTrace();
         System.out.println("동적 로딩 실패");
      } catch (SQLException e) {
         e.printStackTrace();
      }finally {
         try {
            if(psmt != null)
               psmt.close();
            if(conn != null)
               conn.close();
         } catch (SQLException e) {
            e.printStackTrace();
         }
      }
      
      
      
      return cnt;
      
   }
   
   
   
   
   
   
   
}


package 학생정보관리프로그램;

public class Controller {

   // 학생등록을 진행하는 기능 - view에서 입력한 등록할 데이터를 받아주는 역할
   public void insert(StudentDTO dto) {
      
      StudentDAO dao = new StudentDAO();
      int cnt = dao.insert(dto); // cnt
      
      if(cnt > 0) {
         System.out.println("학생 등록 성공");
      }else {
         System.out.println("학생 등록 실패");
      }
      
   }
   
}


package 학생정보관리프로그램;

public class StudentDTO {

   // DTO 
   // Student 테이블에 있는 컬럼만큼 필드, getter가 만들어져 있어야합니다.
   // name, age, gender, major
   
   private String name;
   private int age;
   private String gender;
   private String major;
   
   public StudentDTO(String name, int age, String gender, String major) {
      super();
      this.name = name;
      this.age = age;
      this.gender = gender;
      this.major = major;
   }
   public String getName() {
      return name;
   }
   public int getAge() {
      return age;
   }
   public String getGender() {
      return gender;
   }
   public String getMajor() {
      return major;
   }


}





package 학생정보관리프로그램;

import java.util.Scanner;

public class Main {

   public static void main(String[] args) {

      Scanner sc = new Scanner(System.in);
      
      while(true) {
         
         System.out.print("[1]학생등록 [2]학생전체조회 [3]학생검색 "
               + "[4]학생정보수정 [5]학생정보삭제 [6]프로그램종료 >> ");
         int select = sc.nextInt();
         
         if(select == 1) {
            // 학생 등록
            System.out.print("이름 : ");
            String name = sc.next();
            System.out.print("나이 : ");
            int age = sc.nextInt();
            System.out.print("성별 : ");
            String gender = sc.next();
            System.out.print("전공 : ");
            String major = sc.next();
            // 입력받은 4개의 데이터를 StudentDTO 자료형으로 바꿔주자
            StudentDTO dto = new StudentDTO(name, age, gender, major);
            // dto를 데이터 베이스에 등록하려면
            // Controller에 있는 insert로 전달
            
            Controller con = new Controller();
            con.insert(dto);
            
            
            
         }else if(select == 2) {
            // 학생 전체 조회
         }else if(select == 3) {
            // 학생 검색
         }else if(select == 4) {
            // 학생 정보 수정
         }else if(select == 5) {
            // 학생 정보 삭제
         }else {
            System.out.println("프로그램 종료!");
            break;
         }
         
      }
      
      
   }

}


